/**
 * Phone.com API
 * This is a Phone.com api Swagger definition
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apisupport@phone.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.phone.com/v4';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
* The Full Account Object includes all of the properties in the Account Summary Object, along with the following:
*/
export class AccountFull {
    /**
    * Account ID. Sometimes referred to as \"Voip ID\" or \"voip_id\".
    */
    'id': number;
    /**
    * Name on the account. Read-only.
    */
    'name': string;
    /**
    * Account user name
    */
    'username': string;
    /**
    * Account password. For security reason, this is masked as \"**\"
    */
    'password': string;
    /**
    * If this account is a subaccount, this property shows the master account that it belongs to. Otherwise it is NULL. Read-only. Output is an Account Summary Object.
    */
    'masterAccount': AccountSummary;
    /**
    * Contact Object. See below for details.
    */
    'contact': ContactAccount;
    /**
    * Contact Object for billing purposes. See below for details.
    */
    'billingContact': ContactAccount;
}

/**
* The Account Summary Object is used to briefly represent an account. It can occur in several places throughout this API. Here are the properties:
*/
export class AccountSummary {
    /**
    * Account ID. Sometimes referred to as \"Voip ID\" or \"voip_id\".
    */
    'id': number;
    /**
    * Name on the account. Read-only.
    */
    'name': string;
}

/**
* Contact Address Object. See below for details.
*/
export class Address {
    /**
    * Street address line 1. Required.
    */
    'line1': string;
    /**
    * Street address line 2
    */
    'line2': string;
    /**
    * City. Required.
    */
    'city': string;
    /**
    * Province. Required if country is US
    */
    'province': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * 2-character country code. Required.
    */
    'country': string;
}

export class AddressListContacts {
    /**
    * Address type, one of: home or business. Default is home.
    */
    'type': string;
    /**
    * House number and street name, including apartment, suite, etc.
    */
    'street': string;
    /**
    * City
    */
    'city': string;
    /**
    * State or province
    */
    'state': string;
    /**
    * Zip code or postal code
    */
    'zip': string;
    /**
    * Country name
    */
    'country': string;
}

/**
* The Full Application Object is identical to the Application Summary Object. See above for details.
*/
export class ApplicationFull {
    /**
    * Application ID. Read-only.
    */
    'id': number;
    /**
    * Application name
    */
    'name': string;
}

/**
* The Application Summary Object is used to briefly represent an application. It can occur in several places throughout this API. Here are the properties:
*/
export class ApplicationSummary {
    /**
    * Application ID. Read-only.
    */
    'id': number;
    /**
    * Application name
    */
    'name': string;
}

/**
* The Full Available Phone Number Object includes the properties in the Summary Object, along with the following:
*/
export class AvailableNumbersFull {
    /**
    * Phone number, in E.164 format
    */
    'phoneNumber': string;
    /**
    * Human-readable formatted version of the phone number
    */
    'formatted': string;
    /**
    * The one-time initial price for this number, in USD. Some numbers show REQUEST_QUOTE here. Please contact our sales department if you are interested in these numbers.
    */
    'price': number;
    /**
    * Whether the number is toll-free
    */
    'isTollFree': boolean;
    /**
    * The international dialing prefix for this number. For US and Canadian numbers, for example, this will be \"1\".
    */
    'countryCode': string;
    /**
    * Area code (a.k.a. NPA). Included for North American numbers only.
    */
    'npa': string;
    /**
    * Second 3 digits (a.k.a. NXX). Included for North American numbers only.
    */
    'nxx': string;
    /**
    * Last 4 digits (a.k.a. XXXX). Included for North American numbers only.
    */
    'xxxx': string;
    /**
    * City with which this number is associated, if known. Otherwise NULL.
    */
    'city': string;
    /**
    * State or Province with which this number is associated, if known. Postal Code. Otherwise NULL.
    */
    'province': string;
    /**
    * Country with which this number is associated, if known. Otherwise NULL.
    */
    'country': string;
}

/**
* Each item in the 'details' record may contain the following properties:
*/
export class CallDetails {
    /**
    * UNIX time stamp representing the UTC time that this call item starts
    */
    'startTime': number;
    /**
    * Endpoint for this call item, such as call, voicemail, fax, menu, menu item, queue ...
    */
    'type': string;
    /**
    * ID associated with this call item endpoint (type)
    */
    'idValue': number;
    /**
    * Same as account id
    */
    'voipId': number;
    /**
    * Same as account extension id
    */
    'voipPhoneId': number;
}

/**
* 
*/
export class CallFull {
    /**
    * 
    */
    'id': string;
}

/**
* The Full Call Log Object includes the properties in the Call Log Summary Object, along with the following:
*/
export class CallLogFull {
    /**
    * ID
    */
    'id': string;
    /**
    * Internal system id, may be null
    */
    'uuid': string;
    /**
    * Account extension
    */
    'extension': ExtensionSummary;
    /**
    * Call made from this phone number
    */
    'callerId': string;
    /**
    * Call made to this phone number
    */
    'calledNumber': string;
    /**
    * Call start time
    */
    'startTime': string;
    /**
    * Call log creation time. Same as call end time + time needed to create call log
    */
    'createdAt': string;
    /**
    * Call direction: in or out
    */
    'direction': string;
    /**
    * Call type: call, fax, audiogram ...
    */
    'type': string;
    /**
    * Call duration in seconds
    */
    'callDuration': number;
    /**
    * Was call being monitored?
    */
    'isMonitored': string;
    /**
    * Internal system call reference number
    */
    'callNumber': string;
    /**
    * Last action of call flow
    */
    'finalAction': string;
    /**
    * URL of voicemail if available. User may download the audio via this URL. Empty string if voicemail does not exist
    */
    'voicemailUrl': string;
    /**
    * URL of voicemail if available. User may listen to the audio online via this URL. Empty string if voicemail does not exist
    */
    'voicemailCpUrl': string;
    /**
    * Transcript of voicemail if enabled and available
    */
    'voicemailTranscript': string;
    /**
    * URL of call recording if available. User may download the audio via this URL. Empty string if call recording does not exist
    */
    'callRecordingUrl': string;
    /**
    * URL of call recording if available. User may listen to the audio online via this URL. Empty string if call recording does not exist
    */
    'callRecordingCpUrl': string;
    /**
    * A list of call flows from beginning of call to end of call.
    */
    'details': Array<CallDetails>;
    /**
    * Internal system caller id / name
    */
    'callerCnam': string;
}

/**
* Call Notifications Object or NULL
*/
export class CallNotifications {
    /**
    * Array of email addresses
    */
    'emails': Array<string>;
    /**
    * A phone number capable of receiving SMS messages
    */
    'sms': string;
}

export class CallbackObject {
    /**
    * URL of webhook, where the event is emitted to. Note: The listener supports both HTTP & HTTPS, we highly recommend that users use HTTPS on all callbacks (with user name and password) to ensure no one may send malicious events pretending to be Phone.com.
    */
    'url': string;
    /**
    * Role of callback: main or backup
    */
    'role': string;
    /**
    * HTTP method: get or post
    */
    'verb': string;
    /**
    * Optional user name needed to logon to the webhook URL
    */
    'username': string;
    /**
    * Optional password needed to logon to the webhook URL
    */
    'password': string;
    /**
    * Optional : Duration of HTTP response will time out while sending the event to the callback URL. (1 - 10 seconds)
    */
    'timeout': number;
}

/**
* Here are all of the properties you can expect for Caller ID objects:
*/
export class CallerIdFull {
    /**
    * Phone number, in E.164 format
    */
    'number': string;
    /**
    * Name you have supplied for this number
    */
    'name': string;
    /**
    * Type of Caller ID. account means this number is registered to your account, and extra refers to extra numbers which you have authorized, which are not managed under Phone.com.
    */
    'type': string;
}

/**
* Here are all of the properties you can expect for Caller ID objects:
*/
export class CallerIdPhoneNumber {
    /**
    * Name that this number will be associated with. Must be no longer than 15 characters, and can only contain English letters, numbers, spaces, and commas.
    */
    'name': string;
    /**
    * Can be \"business\" or \"personal\"
    */
    'type': string;
}

export class ContactAccount {
    /**
    * Name. Required.
    */
    'name': string;
    /**
    * Company name
    */
    'company': string;
    'address': Address;
    /**
    * Phone number. Required.
    */
    'phone': string;
    /**
    * Fax number
    */
    'fax': string;
    /**
    * Primary email address. Required.
    */
    'primaryEmail': string;
    /**
    * Alternate email address
    */
    'alternateEmail': string;
}

/**
* The Full Contact Object includes all of the properties in the Contact Summary Object, along with several more:
*/
export class ContactFull {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Salutation, such as Mr, Mrs, or Dr
    */
    'prefix': string;
    /**
    * First name or given name
    */
    'firstName': string;
    /**
    * Middle or second name
    */
    'middleName': string;
    /**
    * Last name or surname
    */
    'lastName': string;
    /**
    * Suffix, such as \"Jr.\", \"Sr.\", \"II\", or \"III\"
    */
    'suffix': string;
    /**
    * Nickname, or a shortened informal version of the contact's name
    */
    'nickname': string;
    /**
    * Name of the contact's company
    */
    'company': string;
    /**
    * Phonetic first name. Useful for remembering how to pronounce the contact's name.
    */
    'phoneticFirstName': string;
    /**
    * Phonetic middle name. Useful for remembering how to pronounce the contact's name.
    */
    'phoneticMiddleName': string;
    /**
    * Phonetic last name. Useful for remembering how to pronounce the contact's name.
    */
    'phoneticLastName': string;
    /**
    * Name of the contact's department
    */
    'department': string;
    /**
    * Contact's job title
    */
    'jobTitle': string;
    /**
    * Array of Contact Email Objects. See below for details.
    */
    'emails': Array<Email>;
    /**
    * Array of Contact Phone Number Objects. See below for details.
    */
    'phoneNumbers': Array<PhoneNumberContact>;
    /**
    * Array of Contact Address Objects. See below for details.
    */
    'addresses': Array<AddressListContacts>;
    'group': GroupListContacts;
    /**
    * Integer UNIX timestamp when the contact was created. Read-only.
    */
    'createdAt': number;
    /**
    * Integer UNIX timestamp when the contact was created. Read-only.
    */
    'updatedAt': number;
}

export class ContactResponse {
    /**
    * Contact name
    */
    'name': string;
    'address': Address;
    /**
    * Primary email address. Required.
    */
    'primaryEmail': string;
    /**
    * Alternate email address
    */
    'alternateEmail': string;
    /**
    * Company name
    */
    'company': string;
    /**
    * Phone number. Required.
    */
    'phone': string;
    /**
    * Fax number
    */
    'fax': string;
}

/**
* The Contact Summary Object is used to briefly represent a contact from your address book. It can be seen in several places throughout this API. Here are the properties:
*/
export class ContactSummary {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Salutation, such as Mr, Mrs, or Dr
    */
    'prefix': string;
    /**
    * First name or given name
    */
    'firstName': string;
    /**
    * Middle or second name
    */
    'middleName': string;
    /**
    * Last name or surname
    */
    'lastName': string;
    /**
    * Suffix, such as 'Jr.', 'Sr.', 'II', or 'III'
    */
    'suffix': string;
    /**
    * Nickname, or a shortened informal version of the contact's name
    */
    'nickname': string;
    /**
    * Name of the contact's company
    */
    'company': string;
}

export class CreateCallParams {
    /**
    * Caller phone number in E.164 format
    */
    'callerPhoneNumber': string;
    /**
    * Caller Extension ID
    */
    'callerExtension': number;
    /**
    * Caller caller ID in E.164 format
    */
    'callerCallerId': string;
    /**
    * Flag to set caller ID to private
    */
    'callerPrivate': string;
    /**
    * Callee phone number in E.164 format
    */
    'calleePhoneNumber': string;
    /**
    * Callee Extension ID
    */
    'calleeExtension': number;
    /**
    * Callee caller ID in E.164 format
    */
    'calleeCallerId': string;
    /**
    * Flag to set callee ID to private
    */
    'calleePrivate': string;
}

export class CreateContactParams {
    /**
    * First Name
    */
    'firstName': string;
    /**
    * Middle Name
    */
    'middleName': string;
    /**
    * Last Name
    */
    'lastName': string;
    /**
    * Prefix
    */
    'prefix': string;
    /**
    * Phonetic First Name
    */
    'phoneticFirstName': string;
    /**
    * Phonetic Middle Name
    */
    'phoneticMiddleName': string;
    /**
    * Phonetic Last Name
    */
    'phoneticLastName': string;
    /**
    * Suffix
    */
    'suffix': string;
    /**
    * Nickname
    */
    'nickname': string;
    /**
    * Company Name
    */
    'company': string;
    /**
    * Department Name
    */
    'department': string;
    /**
    * Job Title
    */
    'jobTitle': string;
    /**
    * Email Addresses
    */
    'emails': Array<Email>;
    /**
    * Phone Numbers
    */
    'phoneNumbers': Array<PhoneNumberContact>;
    /**
    * Addresses
    */
    'addresses': Array<AddressListContacts>;
    /**
    * Contact Group
    */
    'group': any;
}

export class CreateDeviceParams {
    /**
    * Device Name
    */
    'name': string;
    /**
    * List of line objects
    */
    'lines': Array<any>;
}

export class CreateExtensionParams {
    'voicemail': VoicemailInput;
    'callNotifications': CallNotifications;
    /**
    * Caller ID
    */
    'callerId': string;
    /**
    * Extension type
    */
    'usageType': string;
    /**
    * Extension number (auto-generated if empty)
    */
    'extension': number;
    /**
    * Include in dial-by-name directory
    */
    'includeInDirectory': string;
    /**
    * Name (auto-generated if empty)
    */
    'name': string;
    /**
    * Contact name
    */
    'fullName': string;
    /**
    * Timezone
    */
    'timezone': string;
    /**
    * Recording lookup object
    */
    'nameGreeting': any;
    /**
    * Local area code
    */
    'localAreaCode': string;
    /**
    * Enable outgoing calls
    */
    'enableOutboundCalls': string;
    /**
    * Enable Call Waiting
    */
    'enableCallWaiting': string;
}

export class CreateGroupParams {
    /**
    * Group name
    */
    'name': string;
}

export class CreateListenerParams {
    /**
    * Type of listener. Must be 'callback'
    */
    'type': string;
    /**
    * Type of event to subscribe. 'call.new', 'call.update', 'call.complete'
    */
    'eventType': string;
    /**
    * Array of Callback Objects.
    */
    'callbacks': Array<CallbackObject>;
}

export class CreateMediaParams {
    /**
    * Name of media
    */
    'name': string;
    /**
    * 'tts', 'file'
    */
    'origin': string;
    /**
    * 'hold_music', 'greeting'
    */
    'type': string;
    /**
    * 'allison', 'amy', 'belle', 'callie', 'callieq', 'dallas', 'damien', 'david', 'designerdave', 'diane', 'diesel', 'dog', 'duchess', 'duncan', 'emily', 'evilgenius', 'frank', 'french-fry', 'gregory', 'isabelle', 'jean-pierre', 'jerkface', 'katrin', 'kayla', 'kidaroo', 'lawrence', 'layo', 'linda', 'marta', 'matthias', 'miguel', 'millie', 'princess', 'ransomnote', 'robin', 'shouty', 'shygirl', 'tamika', 'tophat', 'vittoria', 'vixen', 'vlad', 'walter', 'whispery', 'william', 'wiseguy', 'zach'
    */
    'ttsVoice': string;
    /**
    * Text used for text-to-speech conversion, maximum 800 characters
    */
    'ttsText': string;
    /**
    * 'Y', 'N'. Media file is temporary, will be deleted after a specified period.
    */
    'isTemparary': string;
    /**
    * If is_temporary is 'Y', media will be deleted after the specified time in seconds
    */
    'expirationDate': number;
    /**
    * Length of media in seconds
    */
    'duration': number;
    /**
    * Notes about the media object
    */
    'notes': string;
    /**
    * 'Y', 'N'. Start playing the media file in random location, instead of from the beginning
    */
    'randomized': string;
}

export class CreateMenuParams {
    'name': string;
    'greeting': any;
    'keypressError': any;
    'allowExtensionDial': string;
    'keypressWaitTime': number;
    'timeoutHandler': any;
    'options': Array<any>;
}

export class CreateOauthParams {
    /**
    * authorization_code, client_credentials, password or refresh_token
    */
    'grantType': string;
    /**
    * Client ID
    */
    'clientId': string;
    /**
    * Client Secret Key
    */
    'clientSecret': string;
    /**
    * Authorization Code created via the /oauth/authorization API
    */
    'code': string;
    /**
    * The redirect URI where user enters authentication information
    */
    'redirectUri': string;
    /**
    * account-owner, extension-user and/or methods:ALL, separated by space (%20)
    */
    'scope': string;
    /**
    * User name
    */
    'username': string;
    /**
    * Password
    */
    'password': string;
    /**
    * Refresh token
    */
    'refreshToken': string;
}

export class CreatePaymentParams {
    /**
    * Name of payment method
    */
    'nickname': string;
    /**
    * primary, onfile or hidden
    */
    'status': string;
    /**
    * Credit Card Type
    */
    'type': string;
    /**
    * Credit Card Token. Token is obtained by entering credit card info via the Credit Card Entry Form
    */
    'ccToken': string;
}

export class CreatePhoneNumberParams {
    /**
    * Phone number
    */
    'phoneNumber': any;
    /**
    * Route lookup object
    */
    'route': any;
    /**
    * Phone Name
    */
    'name': string;
    /**
    * Block incoming calls
    */
    'blockIncoming': string;
    /**
    * Block anonymous calls
    */
    'blockAnonymous': string;
    'callerId': CallerIdPhoneNumber;
    'smsForwarding': SmsForwardingParams;
    'callNotifications': CallNotifications;
}

export class CreatePricingParams {
    /**
    * Pricing plan code
    */
    'pricingId': number;
    /**
    * Reason this pricing plan is added to the subaccount
    */
    'reason': string;
    /**
    * Pricing plan expiration time in UNIX format. Disregard or set it to null for plan which never expires
    */
    'expireDate': number;
}

export class CreateQueueParams {
    /**
    * Name of queue
    */
    'name': string;
    /**
    * Recording lookup object
    */
    'greeting': any;
    /**
    * Recording lookup object
    */
    'holdMusic': any;
    /**
    * Max seconds for hold
    */
    'maxHoldTime': number;
    /**
    * Type of caller id
    */
    'callerIdType': string;
    /**
    * Number of seconds to ring each member
    */
    'ringTime': number;
    /**
    * Extensions or phone numbers
    */
    'members': Array<any>;
}

export class CreateRedirectUriParams {
    /**
    * Redirect URI string for use in redirect-based flows such as the authorization code and implicit flows
    */
    'redirectUri': string;
}

export class CreateRouteParams {
    /**
    * Name
    */
    'name': string;
    /**
    * Rule Sets
    */
    'rules': Array<any>;
    /**
    * Extension Reference
    */
    'extension': any;
}

export class CreateSmsParams {
    /**
    * Phone number of sender
    */
    'from': string;
    /**
    * Outgoing destination numbers
    */
    'to': string;
    /**
    * Text body of the outgoing SMS message. Maximum 160 characters per message.
    */
    'text': string;
    /**
    * ID of Extension where the sms is saved
    */
    'extensionId': number;
}

export class CreateSubaccountParams {
    /**
    * Sub account password
    */
    'username': string;
    /**
    * Sub account password
    */
    'password': string;
    /**
    * Contact Object. See below for details.
    */
    'contact': ContactResponse;
    /**
    * Contact Object for billing purposes. See below for details.
    */
    'billingContact': ContactResponse;
}

export class CreateTrunkParams {
    /**
    * Name of Trunk
    */
    'name': string;
    /**
    * URI of Trunk (in the form of SIP/user@host.com:port)
    */
    'uri': string;
    /**
    * Max concurrent calls
    */
    'maxConcurrentCalls': number;
    /**
    * Max minutes per month
    */
    'maxMinutesPerMonth': number;
    /**
    * Recording lookup object
    */
    'greeting': any;
    /**
    * Recording lookup object
    */
    'errorMessage': any;
    /**
    * Custom audio codec configuration
    */
    'codecs': Array<any>;
}

export class DeleteEntry {
    'success': boolean;
}

/**
* The Full Device Object includes the properties in the Device Summary Object, along with the following:
*/
export class DeviceFull {
    /**
    * ID
    */
    'id': number;
    /**
    * User-supplied name, otherwise NULL
    */
    'name': string;
    'sipAuthentication': SipAuthentication;
    /**
    * Array of Line Objects showing which extensions are attached to this device, and their assigned line numbers. See below for details.
    */
    'lines': Array<Line>;
}

/**
* Device Membership Object, or NULL. Read-only. See below for details.
*/
export class DeviceMembership {
    /**
    * Line number to which this extension is assigned. Integer.
    */
    'line': number;
    /**
    * Device that this extension belongs to. Output is an Device Summary Object.
    */
    'device': DeviceSummary;
}

/**
* The Device Summary Object is used to briefly represent a VoIP device. It consists of the ID and name only:
*/
export class DeviceSummary {
    /**
    * ID
    */
    'id': number;
    /**
    * User-supplied name, otherwise NULL
    */
    'name': string;
}

export class Email {
    /**
    * Email type, one of: primary or alternate. Default is primary.
    */
    'type': string;
    /**
    * Email address. Required.
    */
    'email': string;
}

/**
* The Full Express Service Code Object includes the properties in the Express Service Code Summary Object, along with the following:
*/
export class ExpressServiceCodeFull {
    /**
    * ID
    */
    'id': number;
    /**
    * An 8-digit number in string format
    */
    'expressServiceCode': string;
    /**
    * UNIX time stamp representing the UTC time that the Express Service Code expires. Please note that every time this service is executed, the expire_date is set to now + 24 hours.
    */
    'expireDate': Array<number>;
}

/**
* The Full Extension Object has the same properties as the Extension Summary Object, along with the following:
*/
export class ExtensionFull {
    /**
    * ID of the extension. This is the internal Phone.com ID, not the extension number callers may dial.
    */
    'id': number;
    /**
    * User-supplied name for the extension. On POST, leaving this empty will result in an auto-generated value. On PUT, this field is required.
    */
    'name': string;
    /**
    * Extension number that callers may dial. On POST, leaving this empty will result in an auto-generated value. On PUT, this field is required.
    */
    'extension': number;
    /**
    * API Account ID. Optional, object may return the voip_id.
    */
    'voipId': number;
    /**
    * Full name of the individual or department to which this extension is assigned
    */
    'fullName': string;
    /**
    * Can be \"limited\" or \"unlimited\". In most cases, changing this will affect your monthly bill. Please see our Control Panel or contact Customer Service for pricing.
    */
    'usageType': string;
    'deviceMembership': DeviceMembership;
    /**
    * Time zone. Can be in any commonly recognized format, such as \"America/Los_Angeles\".
    */
    'timezone': string;
    /**
    * Greeting that communicates the extension's name. Output is a Greeting Summary Object. Input must be a Greeting Lookup Object.
    */
    'nameGreeting': MediaSummary;
    /**
    * Whether this extension should be included in the dial-by-name directory for this account. Boolean.
    */
    'includeInDirectory': boolean;
    /**
    * Phone number to use as Caller ID for outgoing calls. Must be a phone number belonging to this account, or one of any additional authorized phone numbers. You can use our List Caller Ids service to see a current list. To unassign, you may set this to \"private\", NULL, or an empty string.
    */
    'callerId': string;
    /**
    * For outbound calls, this is the North American area code that this extension is calling from.
    */
    'localAreaCode': string;
    /**
    * Whether Call Waiting is enabled. Boolean. Default is TRUE.
    */
    'enableCallWaiting': boolean;
    /**
    * Whether outgoing calls are enabled. Boolean. Default is TRUE.
    */
    'enableOutboundCalls': boolean;
    'voicemail': Voicemail;
    'callNotifications': Notification;
    /**
    * Route which will handle incoming voice and fax calls. Only valid on PUT requests, not POST. Output is a Route Summary Object if the route is named, otherwise the Full Route Object will be shown. Input must be a Route Lookup Object pointing to a named route. Route must belong to this extension already.
    */
    'route': RouteSummary;
}

/**
* The Extension Summary Object is used to briefly represent an extension. It can be seen in several places throughout this API. Here are the properties:
*/
export class ExtensionSummary {
    /**
    * ID of the extension. This is the internal Phone.com ID, not the extension number callers may dial.
    */
    'id': number;
    /**
    * User-supplied name for the extension. On POST, leaving this empty will result in an auto-generated value. On PUT, this field is required.
    */
    'name': string;
    /**
    * Extension number that callers may dial. On POST, leaving this empty will result in an auto-generated value. On PUT, this field is required.
    */
    'extension': number;
}

export class FilterCallLogs {
    'id': string;
    'startTime': string;
    'createdAt': string;
    'direction': string;
    'calledNumber': string;
    'type': string;
}

export class FilterIdArray {
    'id': string;
}

export class FilterIdDirectionFrom {
    'id': string;
    'direction': string;
    'from': string;
}

export class FilterIdExtensionNameArray {
    'id': string;
    'extension': string;
    'name': string;
}

export class FilterIdGroupIdUpdatedAtArray {
    'id': string;
    'groupId': string;
    'updatedAt': string;
}

export class FilterIdNameArray {
    'id': string;
    'name': string;
}

export class FilterIdNamePhoneNumberArray {
    'id': string;
    'name': string;
    'phoneNumber': string;
}

export class FilterListAvailableNumbers {
    'phoneNumber': string;
    'countryCode': string;
    'npa': string;
    'nxx': string;
    'xxxx': string;
    'city': string;
    'province': string;
    'country': string;
    'price': string;
    'category': string;
}

export class FilterListPhoneNumbersRegions {
    'countryCode': string;
    'npa': string;
    'nxx': string;
    'isTollFree': string;
    'city': string;
    'provincePostalCode': string;
    'countryPostalCode': string;
}

export class FilterNameNumberArray {
    'name': string;
    'number': string;
}

export class FilterVoicemailArray {
    'id': string;
    'from': string;
    'to': string;
    'isNew': string;
    'createdAt': number;
    'extension': string;
}

/**
* Each entry in a Voicemail's from list is an object with the following properties:
*/
export class FromObject {
    /**
    * The caller phone number
    */
    'number': string;
    /**
    * The name / caller ID of the caller
    */
    'name': string;
    /**
    * The city where the caller is from
    */
    'city': string;
    /**
    * The state where the caller is from
    */
    'state': string;
}

export class GetOauthAccessToken {
    'scope': string;
    'expiresAt': number;
    'scopeDetails': Array<ScopeDetails>;
}

/**
* Voicemail Greeting Object. See below for details. Can be set to NULL to reset greeting options.
*/
export class Greeting {
    /**
    * The greeting to play. Can be \"name\" for the name_greeting as described above, \"standard\" for the standard greeting, or \"alternate\" for an alternate greeting. See below for details.
    */
    'type': string;
    /**
    * Greeting to be played when type=\"alternate\". Output is a Greeting Summary Object. Input must be a Greeting Lookup Object.
    */
    'alternate': MediaSummary;
    /**
    * Greeting to be played when type=\"standard\". Output is a Greeting Summary Object. Input must be a Greeting Lookup Object.
    */
    'standard': MediaSummary;
    /**
    * Whether to prompt the caller with the following words after the voicemail greeting has been played: \"Please leave your message after the tone. When finished, hang up or press the pound key.\" Boolean.
    */
    'enableLeaveMessagePrompt': boolean;
}

/**
* Voicemail Greeting Object. See below for details. Can be set to NULL to reset greeting options.
*/
export class GreetingInput {
    /**
    * The greeting to play. Can be \"name\" for the name_greeting as described above, \"standard\" for the standard greeting, or \"alternate\" for an alternate greeting. See below for details.
    */
    'type': string;
    /**
    * Greeting to be played when type=\"alternate\". Output is a Greeting Summary Object. Input must be a Greeting Lookup Object.
    */
    'alternate': MediaSummary;
    /**
    * Greeting to be played when type=\"standard\". Output is a Greeting Summary Object. Input must be a Greeting Lookup Object.
    */
    'standard': MediaSummary;
    /**
    * Whether to prompt the caller with the following words after the voicemail greeting has been played: \"Please leave your message after the tone. When finished, hang up or press the pound key.\" Boolean.
    */
    'enableLeaveMessagePrompt': string;
}

/**
* The Full Group Object is identical to the Group Summary Object. See above for details.
*/
export class GroupFull {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Name
    */
    'name': string;
}

/**
* Contact Group that this contact is filed under. Output is a Group Summary Object. Input is a Group Lookup Object.
*/
export class GroupListContacts {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Name
    */
    'name': string;
}

/**
* The Group Summary Object is used to briefly represent a contact group. It can occur in several places throughout this API. Here are the properties:
*/
export class GroupSummary {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Name
    */
    'name': string;
}

/**
* Hold Music to be played while callers are waiting. Output is a Media Summary Object. Input must be a Media Lookup Object. Must refer to a media recording that has is_hold_music set to TRUE. Default is to play a standard ring tone.
*/
export class HoldMusic {
    /**
    * Recording ID. Read-only.
    */
    'id': number;
    /**
    * Name of recording
    */
    'name': string;
}

export class Line {
    /**
    * Line number
    */
    'line': number;
    /**
    * Extensions object that this line number is mapped to.
    */
    'extension': ExtensionSummary;
}

export class ListAccounts {
    'filters': FilterIdArray;
    'sort': SortId;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<AccountFull>;
}

export class ListApplications {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<ApplicationFull>;
}

export class ListAvailableNumbers {
    'filters': FilterListAvailableNumbers;
    'sort': SortListAvailableNumbers;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<AvailableNumbersFull>;
}

export class ListCallLogs {
    'filters': FilterCallLogs;
    'sort': SortCallLogs;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<CallLogFull>;
}

export class ListCallerIds {
    'filters': FilterNameNumberArray;
    'sort': SortNameNumber;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<CallerIdFull>;
}

export class ListContacts {
    'filters': FilterIdGroupIdUpdatedAtArray;
    'sort': SortIdUpdatedAt;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<ContactFull>;
}

export class ListDevices {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<DeviceFull>;
}

export class ListExpressServiceCodes {
    'filters': FilterIdArray;
    'sort': Array<SortId>;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<ExpressServiceCodeFull>;
}

export class ListExtensions {
    'filters': FilterIdExtensionNameArray;
    'sort': SortIdExtensionName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<ExtensionFull>;
}

export class ListGroups {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<GroupFull>;
}

export class ListListeners {
    'filters': FilterIdArray;
    'sort': SortId;
    'total': number;
    'limit': number;
    'offset': number;
    'items': Array<ListenerFull>;
}

export class ListMedia {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<MediaSummary>;
}

export class ListMenus {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<MenuFull>;
}

export class ListOauthClients {
    'filters': FilterIdArray;
    'sort': SortId;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<OauthClientFull>;
}

export class ListOauthClientsRedirectUris {
    'filters': FilterIdArray;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<OauthClientRedirectUriFull>;
}

export class ListPaymentMethods {
    'filters': FilterIdArray;
    'sort': SortId;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<PaymentFull>;
}

export class ListPhoneNumbers {
    'filters': FilterIdNamePhoneNumberArray;
    'sort': SortIdNamePhoneNumber;
    'total': number;
    'offset': number;
    'limit': number;
    /**
    * Array of Contact Phone Number Objects. See below for details.
    */
    'items': Array<PhoneNumberFull>;
}

export class ListPhoneNumbersRegions {
    'groupBy': Array<string>;
    'filters': FilterListPhoneNumbersRegions;
    'sort': SortListPhoneNumbersRegions;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<PhoneNumbersRegionFull>;
}

export class ListPricings {
    'filters': FilterIdArray;
    'sort': SortId;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<PricingFull>;
}

export class ListQueues {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<QueueFull>;
}

export class ListRoutes {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<RouteFull>;
}

export class ListSchedules {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<ScheduleFull>;
}

export class ListSms {
    'filters': FilterIdDirectionFrom;
    'sort': SortIdCreatedAt;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<SmsFull>;
}

export class ListTrunks {
    'filters': FilterIdNameArray;
    'sort': SortIdName;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<TrunkFull>;
}

export class ListVoicemail {
    'filters': FilterVoicemailArray;
    'sort': SortIdCreatedAt;
    'total': number;
    'offset': number;
    'limit': number;
    'items': Array<VoicemailFull>;
}

/**
* The Listener Object is used to represent a listener. Here are the properties:
*/
export class ListenerFull {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    'voipId': number;
    /**
    * Type of listener: callback
    */
    'type': string;
    /**
    * Type of event subscribed by the listener: call.new, call.update, call.complete, call.log, sms.in, sms.out
    */
    'eventType': string;
    /**
    * Array of Callback Object
    */
    'callbacks': Array<any>;
    'updatedAt': number;
    'createdAt': number;
}

/**
* The Full Recording Object and the Summary Recording Object are the same.
*/
export class MediaFull {
    /**
    * Recording ID. Read-only.
    */
    'id': number;
    /**
    * Name of recording
    */
    'name': string;
    /**
    * Can be hold_music or greeting. Indicates the purpose of this recording and where it can be used.
    */
    'type': string;
}

/**
* The Recording Summary Object is used to briefly represent a media recording. It can be seen in several places throughout this API. Here are the properties:
*/
export class MediaSummary {
    /**
    * Recording ID. Read-only.
    */
    'id': number;
    /**
    * Name of recording
    */
    'name': string;
}

export class Member {
    /**
    * Extension that this member refers to. Output is an Extension Summary Object. Input must be an Extension Lookup Object.
    */
    'extension': ExtensionSummary;
    /**
    * Phone number
    */
    'phoneNumber': string;
}

/**
* The Full Menu Object contains the same properties as the Menu Summary Object, along with the following:
*/
export class MenuFull {
    /**
    * Integer Menu ID. Read-only.
    */
    'id': number;
    /**
    * Name. Required. Unique.
    */
    'name': string;
    /**
    * Boolean. Determines whether a caller can enter an extension number to bypass the menu.
    */
    'allowExtensionDial': boolean;
    /**
    * Number of seconds to wait for the caller to choose a menu option. Must be between 1 and 5 seconds.
    */
    'keypressWaitTime': number;
    /**
    * Greeting that is played when a caller enters a menu. Output is a Media Summary Object. Input must be a Media Lookup Object. Must refer to a media recording that has is_hold_music set to FALSE.
    */
    'greeting': MediaSummary;
    /**
    * Message that is played when the caller makes a keypress error. Output is a Media Summary Object. Input must be a Media Lookup Object. Must refer to a media recording that has is_hold_music set to FALSE.
    */
    'keypressError': MediaSummary;
    /**
    * Route that will be entered when the caller fails to choose a menu option within the allotted time. Output is a Route Summary Object if the route is named, otherwise the Full Route Object will be shown. Input must be a Route Lookup Object pointing to a named route.
    */
    'timeoutHandler': RouteSummary;
    /**
    * Array of menu option objects. See below for details.
    */
    'options': Array<Option>;
}

/**
* The Menu Summary Object is used to briefly represent a menu. It can be seen in several places throughout this API. Here are the properties:
*/
export class MenuSummary {
    /**
    * Integer Menu ID. Read-only.
    */
    'id': number;
    /**
    * Name. Required. Unique.
    */
    'name': string;
}

/**
* The Call Notifications object configures the recipient(s) of notifications when calls are received to this extension.
*/
export class Notification {
    /**
    * Array of email addresses
    */
    'emails': Array<string>;
    /**
    * Phone number capable of receiving SMS messages
    */
    'sms': string;
}

export class OauthAccessToken {
    'accessToken': string;
    'tokenType': string;
    'scope': string;
    'refreshToken': string;
    'expiresIn': number;
}

/**
* An OAuth Client Full Object is identical as a Summary Object.
*/
export class OauthClientFull {
    /**
    * Client ID
    */
    'id': number;
    /**
    * Name of Client
    */
    'clientName': string;
}

/**
* An OAuth Client Full Object is identical as a Summary Object.
*/
export class OauthClientRedirectUriFull {
    /**
    * OAuth Client Redirect URI ID
    */
    'id': number;
    /**
    * Client details
    */
    'client': OauthClientFull;
    /**
    * Redirect URI details
    */
    'redirectUri': RedirectUriFull;
}

export class Option {
    /**
    * Keypad key. Must equal a single digit or the pound sign (\"#\").
    */
    'key': string;
    /**
    * Route which will be entered when the user presses the designated key. Output is a Route Summary Object if the route is named, otherwise the Full Route Object will be shown. Input must be a Route Lookup Object pointing to a named route.
    */
    'route': RouteSummary;
}

export class PatchPaymentParams {
    /**
    * primary, onfile or hidden
    */
    'status': string;
}

export class PatchSmsParams {
    /**
    * Status of SMS
    */
    'isNew': string;
}

export class PatchVoicemailParams {
    /**
    * Status of voicemail
    */
    'isNew': string;
}

/**
* The Payment Method Full Object contains the same properties as the Payment Method Summary Object, along with the following:
*/
export class PaymentFull {
    /**
    * Payment Method ID
    */
    'id': number;
    /**
    * API Account ID
    */
    'voipId': number;
    /**
    * 'primary' = primary card used for billing; 'onfile' = card on file; 'hidden' = deleted card;
    */
    'status': string;
    /**
    * Name of Card
    */
    'nickname': string;
    /**
    * 'cc' for credit card
    */
    'type': string;
    /**
    * Time payment record is created
    */
    'createdAt': number;
    /**
    * Detail of contact person
    */
    'contact': ContactResponse;
    /**
    * Number of times the payment method was declined
    */
    'declineCount': number;
    /**
    * Next billing date
    */
    'nextChargeDate': number;
    /**
    * Last time the payment method was updated
    */
    'updatedAt': number;
    /**
    * Encrypted credit card token to be used for billing
    */
    'ccToken': string;
    /**
    * Credit card number partially masked with xxxxxxxx
    */
    'ccNumber': string;
    /**
    * Credit card expiration date
    */
    'ccExp': string;
}

/**
* The Payment Method Summary Object is used to briefly represent a Credit Card. It consists of parameters in the table below:
*/
export class PaymentSummary {
    /**
    * Payment Method ID
    */
    'id': number;
    /**
    * API Account ID
    */
    'voipId': number;
    /**
    * 'primary' = primary card used for billing; 'onfile' = card on file; 'hidden' = deleted card;
    */
    'status': string;
    /**
    * Name of Card
    */
    'nickname': string;
    /**
    * 'cc' for credit card
    */
    'type': string;
    /**
    * Time payment record is created
    */
    'createdAt': number;
}

export class PhoneNumberContact {
    /**
    * Type of phone number, must be one of: home, business, mobile, fax, pager. Default is home.
    */
    'type': string;
    /**
    * Phone number, as entered. Does not need to be formatted in any particular way. Required.
    */
    'number': string;
    /**
    * Phone number in E.164 format. Read-only.
    */
    'normalized': string;
}

/**
* The Full Phone Number Object has all of the properties of the Phone Number Summary Object, along with several more, as shown below:
*/
export class PhoneNumberFull {
    /**
    * Integer Phone number ID. This is the internal Phone.com ID for this number, not the phone number itself. Read-only.
    */
    'id': number;
    /**
    * Name
    */
    'name': string;
    /**
    * Phone number, in E.164 format
    */
    'phoneNumber': string;
    /**
    * Whether to block incoming calls. Boolean.
    */
    'blockIncoming': boolean;
    /**
    * Whether to block anonymous calls. Boolean.
    */
    'blockAnonymous': boolean;
    /**
    * The Route assigned to handle incoming calls for this number, if any. Output is a Route Summary Object, or NULL if not set. Input can be a Route Lookup Object or NULL to unset.
    */
    'route': RouteSummary;
    'callerId': CallerIdPhoneNumber;
    'smsForwarding': SmsForwarding;
    'callNotifications': CallNotifications;
}

/**
* The Region Object may include any of several fields describing the group, as well as the quantity of phone numbers available in that group. Here are the properties:
*/
export class PhoneNumbersRegionFull {
    /**
    * Optional. Integer representing the international calling code for the phone number's country.
    */
    'countryCode': string;
    /**
    * Optional. Area Code, for North American phone numbers.
    */
    'npa': number;
    /**
    * Optional. Second set of 3 digits, for North American phone numbers.
    */
    'nxx': number;
    /**
    * Optional. Boolean describing whether the phone numbers in this group are toll free.
    */
    'isTollFree': number;
    /**
    * Optional. City name.
    */
    'city': string;
    /**
    * Optional. Two-letter postal code for the state or province.
    */
    'provincePostalCode': string;
    /**
    * Optional. Two-letter postal code for the country.
    */
    'countryPostalCode': string;
    /**
    * Integer. Quantity of phone numbers currently available in the given region.
    */
    'quantity': number;
}

/**
* The ping response object.
*/
export class PingResponse {
    'datetime': string;
    'remoteIp': string;
    'timestamp': number;
    'userAgent': string;
}

/**
* The Full Pricing Object is identical to the Pricing Summary Object. The Pricing Summary Object is used to briefly represent a pricing plan. Here are the properties:
*/
export class PricingFull {
    /**
    * Integer ID of this object.
    */
    'id': number;
    /**
    * Pricing Object
    */
    'pricing': PricingObject;
    /**
    * Phone.com API Account (VoIP) ID
    */
    'voipId': number;
    /**
    * Reason this pricing plan is applied
    */
    'reason': string;
    /**
    * Name of the person / process who added this pricing plan to the subaccount
    */
    'who': string;
    /**
    * Pricing plan expiration timestamp in unix format. If pricing plan never expires, this item will not be returned
    */
    'expireDate': string;
}

export class PricingObject {
    /**
    * Pricing code / ID
    */
    'id': number;
    /**
    * Name of pricing plan
    */
    'name': string;
}

/**
* The Full QueueObject has the same properties as the Queue Summary Object, along with the following:
*/
export class QueueFull {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Name. Required.
    */
    'name': string;
    /**
    * Greeting to be played when caller first connects. Output is a Media Summary Object. Input must be a Media Lookup Object. Must refer to a media recording that has is_hold_music set to FALSE. Can be set to NULL to disable the greeting.
    */
    'greeting': MediaSummary;
    'holdMusic': HoldMusic;
    /**
    * Maximum hold time in seconds. If provided, must equal one of: 60, 120, 180, 240, 300, 600, 900, 1200, 1800, 2700, 3600. Default is 300.
    */
    'maxHoldTime': number;
    /**
    * Caller id type to show members. If provided, must equal one of: 'called_number', 'calling_number'. Default is 'calling_number'.
    */
    'callerIdType': string;
    /**
    * Number of seconds to ring a member before cycling to the next member. If provided, must equal one of: 5, 10, 15, 20, 25, 30. Default is 5.
    */
    'ringTime': number;
    /**
    * Array of Member Objects. Non-virtual account extensions or phone numbers. See below for details.
    */
    'members': Array<Member>;
}

/**
* The Queue Summary Object is used to briefly represent a calling queue. It can be seen in several places throughout this API. Here are the properties:
*/
export class QueueSummary {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Name. Required.
    */
    'name': string;
}

export class Recipient {
    /**
    * Phone number that will receive the SMS message
    */
    'number': string;
    /**
    * Indicate the status of your SMS object. May be 'sent', 'received', 'queued', 'new' ...
    */
    'status': string;
}

export class RedirectUriFull {
    /**
    * Redirect URI ID
    */
    'id': number;
    /**
    * The Uniform Resource Identifier is a string used to identify the path to be redirected
    */
    'uri': string;
    /**
    * redirect
    */
    'type': string;
}

export class ReplaceExtensionParams {
    'voicemail': VoicemailInput;
    'callNotifications': CallNotifications;
    /**
    * Recording lookup object
    */
    'nameGreeting': any;
    /**
    * Name (required)
    */
    'name': string;
    /**
    * Timezone
    */
    'timezone': string;
    /**
    * Include in dial-by-name directory
    */
    'includeInDirectory': string;
    /**
    * Extension number (required)
    */
    'extension': number;
    /**
    * Enable outgoing calls
    */
    'enableOutboundCalls': string;
    /**
    * Extension type
    */
    'usageType': string;
    /**
    * Contact name
    */
    'fullName': string;
    /**
    * Enable Call Waiting
    */
    'enableCallWaiting': string;
    /**
    * Caller ID
    */
    'callerId': string;
    /**
    * Local area code
    */
    'localAreaCode': string;
    /**
    * Route object lookup (must belong to this extension)
    */
    'route': string;
}

export class ReplaceMenuParams {
    'name': string;
    'greeting': any;
    'keypressError': any;
    'allowExtensionDial': string;
    'keypressWaitTime': number;
    'timeoutHandler': any;
    'options': Array<any>;
}

export class ReplacePhoneNumberParams {
    /**
    * Route lookup object
    */
    'route': any;
    /**
    * Phone Name
    */
    'name': string;
    /**
    * Block incoming calls
    */
    'blockIncoming': string;
    /**
    * Block anonymous calls
    */
    'blockAnonymous': string;
    'callerId': CallerIdPhoneNumber;
    'smsForwarding': SmsForwardingParams;
    /**
    * Pool lookup object
    */
    'poolItem': any;
    'callNotifications': CallNotifications;
}

/**
* The root level of the Full Route Object includes all of the properties in the Route Summary Object, along with two more:
*/
export class RouteFull {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Name
    */
    'name': string;
    /**
    * Extension to which this route belongs. Output is an Extension Summary Object. Input must be an Extension Lookup Object. Optional. Cannot be changed after a route is created.
    */
    'extension': ExtensionSummary;
    /**
    * Array of Rule Set Objects. Required. See below for details. When processing incoming calls, the first matching rule set will be used, and all others will be ignored.
    */
    'rules': Array<RuleSet>;
}

/**
* The Route Summary Object is used to briefly represent a route. It can be seen in several places throughout this API. Here are the properties:
*/
export class RouteSummary {
    /**
    * Integer ID. Read-only.
    */
    'id': number;
    /**
    * Name
    */
    'name': string;
}

export class RuleSet {
    'filter': RuleSetFilter;
    /**
    * Array of Action Objects. Required. Routes have rule sets, and rule sets have one or more actions. The supported actions are described below:
    */
    'actions': Array<RuleSetAction>;
}

/**
* Filter Object. Optional. See below for details.
*/
export class RuleSetAction {
    /**
    * Required.
    */
    'action': string;
    /**
    * Extension that this action refers to. Output is an Extension Summary Object. Input must be an Extension Lookup Object. Required.
    */
    'extension': ExtensionSummary;
    /**
    * This action is for forwarding calls to any number of extensions or phone numbers. The forwarding is handled in parallel, meaning that all phone numbers and/or extensions will ring simultaneously. When the call is answered by any single phone number or extension, ringing will stop for all of them. Subsequent actions in this rule set will be performed if the call is not answered before the timeout period is reached, or if it is forwarded to an extension that has its own route and that route does not result in any actions that disconnect the call or take over call handling.
    */
    'items': Array<RuleSetForwardItem>;
    /**
    * Seconds that our routing engine should wait until moving on. Optional. Must be an integer between 5 and 90. Default is 5 seconds.
    */
    'timeout': number;
    /**
    * Hold Music to be played while callers are waiting. Output is a Media Summary Object. Input must be a Media Lookup Object. Optional. Must refer to a media recording that has is_hold_music set to TRUE. Default is to play a standard ring tone.
    */
    'holdMusic': MediaSummary;
    /**
    * Greeting that this action refers to. Output is a Media Summary Object. Input must be a Media Lookup Object. Required. Must refer to a media recording that has is_hold_music set to FALSE.
    */
    'greeting': MediaSummary;
    /**
    * Required. Seconds that the caller should be placed on hold before being moved onto the next action. Must be an integer between 1 and 60 seconds.
    */
    'duration': number;
    /**
    * Menu that this action refers to. Required. Output is a Menu Summary Object. Input must be a Menu Lookup Object.
    */
    'menu': MenuSummary;
    /**
    * Queue that this action refers to. Required. Output is a Queue Summary Object. Input must be a Queue Lookup Object.
    */
    'queue': QueueSummary;
    /**
    * Trunk that this action refers to. Required. Output is a Trunk Summary Object. Input must be a Trunk Lookup Object.
    */
    'trunk': TrunkSummary;
}

/**
* Filter Object. Optional. See below for details.
*/
export class RuleSetFilter {
    /**
    * Required.
    */
    'type': string;
    /**
    * Schedule that this filter refers to. Output is a Schedule Summary Object. Input must be a Schedule Lookup Object. Required.
    */
    'schedule': ScheduleSummary;
    /**
    * Address Book Contact that this filter refers to. Output is a Contact Summary Object. Input must be a Contact Lookup Object. Required.
    */
    'contact': ContactSummary;
    /**
    * Address Book Group that this filter refers to. Output is a Contact Group Summary Object. Input must be a Contact Group Lookup Object. Required.
    */
    'group': GroupSummary;
}

/**
* Array of Forward Item Objects. See below for details. Required.
*/
export class RuleSetForwardItem {
    /**
    * Required. Must equal phone_number or extension.
    */
    'type': string;
    /**
    * Required if type = \"extension\". Extension that callers should be directed to. Output is an Extension Summary Object. Input must be an Extension Lookup Object.
    */
    'extension': ExtensionSummary;
    /**
    * Required if type = \"phone_number\". Phone number that callers should be directed to. Must be a string in E.164 format.
    */
    'number': string;
    /**
    * Boolean. Optional. Default is FALSE. Use this to activate call screening. If TRUE, the timeout on the parent action should be at least 30 seconds.
    */
    'screening': boolean;
    /**
    * Optional. Must equal calling_number or called_number. Defines which phone number should be used for Caller ID. Default is calling_number.
    */
    'callerId': string;
    /**
    * Optional string. If screening = TRUE, this value will be passed into our Text-To-Speech engine and used to inform the caller of who they have reached.
    */
    'voiceTag': string;
    /**
    * Optional. Must equal one of: DEFAULT, STYLE_2, STYLE_3, STYLE_4, STYLE_5, STYLE_6, STYLE_7, STYLE_8, or STYLE_9. Identifies the style of ring tone you will hear when an incoming call is waiting.
    */
    'distinctiveRing': string;
}

/**
* The Full Schedule Object is identical to the Schedule Summary Object. See above for details.
*/
export class ScheduleFull {
    /**
    * Integer Schedule ID. Read-only.
    */
    'id': number;
    /**
    * Name
    */
    'name': string;
}

/**
* The Schedule Summary Object is used to briefly represent a schedule. It can be seen in several places throughout this API. Here are the properties:
*/
export class ScheduleSummary {
    /**
    * Integer Schedule ID. Read-only.
    */
    'id': number;
    /**
    * Name
    */
    'name': string;
}

export class ScopeDetails {
    'voipId': number;
}

/**
* A SIP Authentication Properties Object. See below for details. Read-only.
*/
export class SipAuthentication {
    /**
    * Hostname
    */
    'host': string;
    /**
    * Port number
    */
    'port': number;
    /**
    * Username. This is the ID of the device.
    */
    'username': string;
    /**
    * Password.
    */
    'password': string;
}

/**
* SMS Forwarding Object, or NULL
*/
export class SmsForwarding {
    /**
    * Can be \"extension\" or \"application\"
    */
    'type': string;
    /**
    * Required if type = \"extension\". Extension that messages should be directed to. Output is an Extension Summary Object. Input must be an Extension Lookup Object.
    */
    'extension': ExtensionSummary;
    /**
    * Required if type = \"application\". Application that messages should be directed to. Output is an Application Summary Object. Input must be an Application Lookup Object.
    */
    'application': ApplicationSummary;
}

/**
* SMS Forwarding Object, or NULL
*/
export class SmsForwardingParams {
    /**
    * Can be \"extension\" or \"application\"
    */
    'type': string;
    /**
    * Required if type = \"extension\". Extension that messages should be directed to. Output is an Extension Summary Object. Input must be an Extension Lookup Object.
    */
    'extension': number;
    /**
    * Required if type = \"application\". Application that messages should be directed to. Output is an Application Summary Object. Input must be an Application Lookup Object.
    */
    'application': number;
}

/**
* The Full SMS Object includes all of the properties in the SMS Summary Object.
*/
export class SmsFull {
    /**
    * Unique SMS ID. Read-only.
    */
    'id': string;
    /**
    * Caller ID number to display on the incoming/outgoing SMS message. For an outgoing message, it must be a phone number associated with your Phone.com account.
    */
    'from': string;
    /**
    * An array of SMS recipients.
    */
    'to': Array<Recipient>;
    /**
    * Direction of SMS. 'in' for Incoming messages, 'out' for Outgoing messages.
    */
    'direction': string;
    /**
    * Unix time stamp representing the UTC time that the object was created in the Phone.com API system.
    */
    'createdEpoch': number;
    /**
    * Date string representing the UTC time that the object was created in the Phone.com API system.
    */
    'createdAt': Date;
    /**
    * Body of the SMS text
    */
    'text': string;
    /**
    * True when SMS is new; False when SMS has been read.
    */
    'isNew': boolean;
}

export class SortCallLogs {
    'id': string;
    'startTime': string;
    'createdAt': string;
}

export class SortId {
    'id': string;
}

export class SortIdCreatedAt {
    'id': string;
    'createdAt': string;
}

export class SortIdExtensionName {
    'id': string;
    'extension': string;
    'name': string;
}

export class SortIdName {
    'id': string;
    'name': string;
}

export class SortIdNamePhoneNumber {
    'id': string;
    'name': string;
    'phoneNumber': string;
}

export class SortIdUpdatedAt {
    'id': string;
    'updatedAt': string;
}

export class SortListAvailableNumbers {
    'internal': string;
    'price': string;
    'phoneNumber': string;
}

export class SortListPhoneNumbersRegions {
    'countryCode': string;
    'npa': string;
    'nxx': string;
    'isTollFree': string;
    'city': string;
    'provincePostalCode': string;
    'countryPostalCode': string;
}

export class SortNameNumber {
    'name': string;
    'number': string;
}

/**
* The Full Trunk Object is identical to the Trunk Summary Object, along with the following:
*/
export class TrunkFull {
    /**
    * Integer Trunk ID. Read-only.
    */
    'id': number;
    /**
    * Name. Required.
    */
    'name': string;
    /**
    * Fully-qualified SIP URI. Required.
    */
    'uri': string;
    /**
    * Max concurrent calls. Default is 10.
    */
    'maxConcurrentCalls': number;
    /**
    * Max minutes per month. Default is 750.
    */
    'maxMinutesPerMonth': number;
    /**
    * Greeting. Output is a Media Summary Object. Input must be a Media Lookup Object. Must refer to a media recording that has is_hold_music set to FALSE.
    */
    'greeting': MediaSummary;
    /**
    * Error Message. Output is a Media Summary Object. Input must be a Media Lookup Object. Must refer to a media recording that has is_hold_music set to FALSE.
    */
    'errorMessage': MediaSummary;
    /**
    * Custom audio codec configuration, if any is needed. If provided, must be a simple array containing the prioritized list of desired codecs. Supported codecs are: g711u 64k, g711u 56k, g711a 64k, g711a 56k, g7231, g728, g729, g729A, g729B, g729AB, gms full, rfc2833, t38, ilbc, h263, g722, g722_1, g729D, g729E, amr, amr_wb, efr, evrc, h264, mpeg4, red, cng, SIP Info to 2833
    */
    'codecs': Array<string>;
}

/**
* The Trunk Summary Object is used to briefly represent a trunk. It can be seen in several places throughout this API. Here are the properties:
*/
export class TrunkSummary {
    /**
    * Integer Trunk ID. Read-only.
    */
    'id': number;
    /**
    * Name. Required.
    */
    'name': string;
}

/**
* Voicemail Object. See below for details.
*/
export class Voicemail {
    /**
    * Whether voicemail is enabled. Boolean.
    */
    'enabled': boolean;
    /**
    * Password for accessing voicemail box. Must be digits only.
    */
    'password': string;
    'greeting': Greeting;
    /**
    * If notification emails are being used, this defines the format of the audio attachments. Can be \"wav\" for WAV format, \"mp3\" for MP3 format, or NULL to disable attachments.
    */
    'attachments': string;
    /**
    * Voicemail Notifications Object. See below for details. Can be set to NULL to disable notifications.
    */
    'notifications': Notification;
    /**
    * Type of voicemail transcription to use. Can be \"human\" for high-quality manual transcriptions by human operators, \"automated\" for machine-generated transcriptions, or NULL to omit trancriptions. Changing this option will affect your monthly bill. Please see our Control Panel or contact Customer Service for details.
    */
    'transcription': string;
}

/**
* The Full Voicemail Object includes all of the properties in the Voicemail Summary Object.
*/
export class VoicemailFull {
    /**
    * Unique Voicemail ID. Read-only.
    */
    'id': string;
    /**
    * Name. Required.
    */
    'downloadUrl': string;
    /**
    * Extension where the voicemail is saved into.
    */
    'extension': ExtensionSummary;
    /**
    * The caller's information
    */
    'from': FromObject;
    /**
    * The phone number where the caller is calling
    */
    'to': string;
    /**
    * True when Voicemail is new; False when Voicemail has been listened
    */
    'isNew': boolean;
    /**
    * Date string representing the UTC time that the object was created in the Phone.com API system.
    */
    'createdAt': number;
    /**
    * Folder name where voicemail is saved
    */
    'folder': string;
    /**
    * Length of voicemail in seconds
    */
    'duration': number;
}

/**
* Voicemail Object. See below for details.
*/
export class VoicemailInput {
    /**
    * Whether voicemail is enabled. Boolean.
    */
    'enabled': string;
    /**
    * Password for accessing voicemail box. Must be digits only.
    */
    'password': string;
    'greeting': GreetingInput;
    /**
    * If notification emails are being used, this defines the format of the audio attachments. Can be \"wav\" for WAV format, \"mp3\" for MP3 format, or NULL to disable attachments.
    */
    'attachments': string;
    /**
    * Voicemail Notifications Object. See below for details. Can be set to NULL to disable notifications.
    */
    'notifications': Notification;
    /**
    * Type of voicemail transcription to use. Can be \"human\" for high-quality manual transcriptions by human operators, \"automated\" for machine-generated transcriptions, or NULL to omit trancriptions. Changing this option will affect your monthly bill. Please see our Control Panel or contact Customer Service for details.
    */
    'transcription': string;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AccountsApiApiKeys {
    apiKey,
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        this.authentications[AccountsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieve details of an individual account. See Accounts for more info on the properties.
     * @summary Retrieve details of an individual account
     * @param accountId Account ID
     */
    public getAccount (accountId: number) : Promise<{ response: http.ClientResponse; body: AccountFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccountFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of accounts visible to the authenticated user or client. In most cases, there will only be one such account. See Accounts for more info on the properties.
     * @summary Get a list of accounts visible to the authenticated user or client.
     * @param filters[id] ID filter
     * @param sort[id] ID sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccounts (filters[id]?: Array<string>, sort[id]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListAccounts;  }> {
        const localVarPath = this.basePath + '/accounts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListAccounts;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApplicationsApiApiKeys {
    apiKey,
}

export class ApplicationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApplicationsApiApiKeys, value: string) {
        this.authentications[ApplicationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Show details of an individual Application on a given account.
     * @summary Show details of an individual Application on a given account.
     * @param accountId Account ID
     * @param applicationId Application ID
     */
    public getAccountApplication (accountId: number, applicationId: number) : Promise<{ response: http.ClientResponse; body: ApplicationFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/applications/{application_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'application_id' + '}', String(applicationId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountApplication.');
        }

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getAccountApplication.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApplicationFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual Application on a given account.
     * @summary This service lists the Applications on a given account
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountApplications (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListApplications;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/applications'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountApplications.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListApplications;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AvailablenumbersApiApiKeys {
    apiKey,
}

export class AvailablenumbersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AvailablenumbersApiApiKeys, value: string) {
        this.authentications[AvailablenumbersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary 
     * @param filters[phoneNumber] Phone number filter
     * @param filters[countryCode] Country Code filter
     * @param filters[npa] Area Code filter (North America only)
     * @param filters[nxx] 2nd set of 3 digits filter (North America only)
     * @param filters[xxxx] NANP XXXX filter
     * @param filters[city] City filter
     * @param filters[province] State or Province (postal code) filter
     * @param filters[country] Country (postal code) filter
     * @param filters[price] Price filter
     * @param filters[category] Category filter
     * @param sort[internal] Internal (quasi-random) sorting
     * @param sort[price] Price sorting
     * @param sort[phoneNumber] Phone number sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAvailablePhoneNumbers (filters[phoneNumber]?: Array<string>, filters[countryCode]?: Array<string>, filters[npa]?: Array<string>, filters[nxx]?: Array<string>, filters[xxxx]?: Array<string>, filters[city]?: Array<string>, filters[province]?: Array<string>, filters[country]?: Array<string>, filters[price]?: Array<string>, filters[category]?: Array<string>, sort[internal]?: string, sort[price]?: string, sort[phoneNumber]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListAvailableNumbers;  }> {
        const localVarPath = this.basePath + '/phone-numbers/available';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filters[phoneNumber] !== undefined) {
            queryParameters['filters[phone_number]'] = filters[phoneNumber];
        }

        if (filters[countryCode] !== undefined) {
            queryParameters['filters[country_code]'] = filters[countryCode];
        }

        if (filters[npa] !== undefined) {
            queryParameters['filters[npa]'] = filters[npa];
        }

        if (filters[nxx] !== undefined) {
            queryParameters['filters[nxx]'] = filters[nxx];
        }

        if (filters[xxxx] !== undefined) {
            queryParameters['filters[xxxx]'] = filters[xxxx];
        }

        if (filters[city] !== undefined) {
            queryParameters['filters[city]'] = filters[city];
        }

        if (filters[province] !== undefined) {
            queryParameters['filters[province]'] = filters[province];
        }

        if (filters[country] !== undefined) {
            queryParameters['filters[country]'] = filters[country];
        }

        if (filters[price] !== undefined) {
            queryParameters['filters[price]'] = filters[price];
        }

        if (filters[category] !== undefined) {
            queryParameters['filters[category]'] = filters[category];
        }

        if (sort[internal] !== undefined) {
            queryParameters['sort[internal]'] = sort[internal];
        }

        if (sort[price] !== undefined) {
            queryParameters['sort[price]'] = sort[price];
        }

        if (sort[phoneNumber] !== undefined) {
            queryParameters['sort[phone_number]'] = sort[phoneNumber];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListAvailableNumbers;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CalleridsApiApiKeys {
    apiKey,
}

export class CalleridsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CalleridsApiApiKeys, value: string) {
        this.authentications[CalleridsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Show the Caller ID options a given extension can use. See Intro to Caller IDs for more on the properties.
     * @summary Show the Caller ID options a given extension can use.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param filters[number] Number filter
     * @param filters[name] Name filter
     * @param sort[number] Number sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public getCallerIds (accountId: number, extensionId: number, filters[number]?: Array<string>, filters[name]?: Array<string>, sort[number]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListCallerIds;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/caller-ids'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getCallerIds.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling getCallerIds.');
        }

        if (filters[number] !== undefined) {
            queryParameters['filters[number]'] = filters[number];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[number] !== undefined) {
            queryParameters['sort[number]'] = sort[number];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListCallerIds;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CalllogsApiApiKeys {
    apiKey,
}

export class CalllogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CalllogsApiApiKeys, value: string) {
        this.authentications[CalllogsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Show details of an individual Call Log entry. See Call Logs for more detail.
     * @summary Show details of an individual Call Log entry
     * @param accountId Account ID
     * @param callId Call ID
     */
    public getAccountCallLogs (accountId: number, callId: string) : Promise<{ response: http.ClientResponse; body: CallLogFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/call-logs/{call_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'call_id' + '}', String(callId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountCallLogs.');
        }

        // verify required parameter 'callId' is not null or undefined
        if (callId === null || callId === undefined) {
            throw new Error('Required parameter callId was null or undefined when calling getAccountCallLogs.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CallLogFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of call details associated with your account. See Call Logs for more detail.
     * @summary Get a list of call details associated with your account
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[startTime] Call start time filter
     * @param filters[createdAt] Call log creation time filter
     * @param filters[direction] Call direction filter: in or out
     * @param filters[calledNumber] Called number
     * @param filters[type] Call type, such as &#39;call&#39;, &#39;fax&#39;, &#39;audiogram&#39;
     * @param filters[extension] Extension filter
     * @param sort[id] ID sorting
     * @param sort[startTime] Sorting by call start time: asc or desc
     * @param sort[createdAt] Sorting by call log creation time: asc or desc
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountCallLogs (accountId: number, filters[id]?: Array<string>, filters[startTime]?: Array<string>, filters[createdAt]?: string, filters[direction]?: string, filters[calledNumber]?: string, filters[type]?: string, filters[extension]?: Array<string>, sort[id]?: string, sort[startTime]?: string, sort[createdAt]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListCallLogs;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/call-logs'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountCallLogs.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[startTime] !== undefined) {
            queryParameters['filters[start_time]'] = filters[startTime];
        }

        if (filters[createdAt] !== undefined) {
            queryParameters['filters[created_at]'] = filters[createdAt];
        }

        if (filters[direction] !== undefined) {
            queryParameters['filters[direction]'] = filters[direction];
        }

        if (filters[calledNumber] !== undefined) {
            queryParameters['filters[called_number]'] = filters[calledNumber];
        }

        if (filters[type] !== undefined) {
            queryParameters['filters[type]'] = filters[type];
        }

        if (filters[extension] !== undefined) {
            queryParameters['filters[extension]'] = filters[extension];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[startTime] !== undefined) {
            queryParameters['sort[start_time]'] = sort[startTime];
        }

        if (sort[createdAt] !== undefined) {
            queryParameters['sort[created_at]'] = sort[createdAt];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListCallLogs;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CallsApiApiKeys {
    apiKey,
}

export class CallsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CallsApiApiKeys, value: string) {
        this.authentications[CallsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Make a phone call. See Calls for more details and how to setup caller id's. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Calls API with the following definition: POST https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/calls
     * @summary Make a phone call
     * @param accountId Account ID
     * @param data Call data
     */
    public createAccountCall (accountId: number, data?: CreateCallParams) : Promise<{ response: http.ClientResponse; body: CallFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/calls'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountCall.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CallFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContactsApiApiKeys {
    apiKey,
}

export class ContactsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContactsApiApiKeys, value: string) {
        this.authentications[ContactsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a new address book contact for an extension. See Account Contacts for more info on the fields in each item.
     * @summary Add a new address book contact for an extension.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param data Contact data
     */
    public createAccountExtensionContact (accountId: number, extensionId: number, data?: CreateContactParams) : Promise<{ response: http.ClientResponse; body: ContactFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contacts'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountExtensionContact.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling createAccountExtensionContact.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ContactFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a contact from the address book. See Account Contacts for more info on the fields in each item.
     * @summary Delete a contact from the address book.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param contactId Contact ID
     */
    public deleteAccountExtensionContact (accountId: number, extensionId: number, contactId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contacts/{contact_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId))
            .replace('{' + 'contact_id' + '}', String(contactId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountExtensionContact.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling deleteAccountExtensionContact.');
        }

        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling deleteAccountExtensionContact.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the details of an address book contact. See Account Contacts for more info on the fields in each item.
     * @summary Retrieve the details of an address book contact.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param contactId Contact ID
     */
    public getAccountExtensionContact (accountId: number, extensionId: number, contactId: number) : Promise<{ response: http.ClientResponse; body: ContactFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contacts/{contact_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId))
            .replace('{' + 'contact_id' + '}', String(contactId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountExtensionContact.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling getAccountExtensionContact.');
        }

        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling getAccountExtensionContact.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ContactFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show the Caller ID options a given extension can use. See Intro to Caller IDs for more on the properties.
     * @summary Show the Caller ID options a given extension can use.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param filters[id] ID filter
     * @param filters[groupId] Group filter
     * @param filters[updatedAt] Updated At filter
     * @param sort[id] ID sorting
     * @param sort[updatedAt] Updated At sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountExtensionContacts (accountId: number, extensionId: number, filters[id]?: Array<string>, filters[groupId]?: Array<string>, filters[updatedAt]?: Array<string>, sort[id]?: string, sort[updatedAt]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListContacts;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contacts'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountExtensionContacts.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling listAccountExtensionContacts.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[groupId] !== undefined) {
            queryParameters['filters[group_id]'] = filters[groupId];
        }

        if (filters[updatedAt] !== undefined) {
            queryParameters['filters[updated_at]'] = filters[updatedAt];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[updatedAt] !== undefined) {
            queryParameters['sort[updated_at]'] = sort[updatedAt];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListContacts;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the info of a contact in the address book. See Account Contacts for more info on the fields in each item.
     * @summary Update the info of a contact in the address book.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param contactId Contact ID
     * @param data Contact data
     */
    public replaceAccountExtensionContact (accountId: number, extensionId: number, contactId: number, data?: CreateContactParams) : Promise<{ response: http.ClientResponse; body: ContactFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contacts/{contact_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId))
            .replace('{' + 'contact_id' + '}', String(contactId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountExtensionContact.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling replaceAccountExtensionContact.');
        }

        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling replaceAccountExtensionContact.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ContactFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefaultApiApiKeys {
    apiKey,
}

export class DefaultApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     * The default API command
     * @summary The default API command
     */
    public ping () : Promise<{ response: http.ClientResponse; body: PingResponse;  }> {
        const localVarPath = this.basePath + '/ping';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PingResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DevicesApiApiKeys {
    apiKey,
}

export class DevicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DevicesApiApiKeys, value: string) {
        this.authentications[DevicesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Register a generic VoIP device. See Devices for more detail.
     * @summary Register a generic VoIP device.
     * @param accountId Account ID
     * @param data Device data
     */
    public createAccountDevice (accountId: number, data?: CreateDeviceParams) : Promise<{ response: http.ClientResponse; body: DeviceFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/devices'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a VoIP device. See Devices for more detail.
     * @summary Delete a VoIP device.
     * @param accountId Account ID
     * @param deviceId Device ID
     */
    public deleteAccountDevice (accountId: number, deviceId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/devices/{device_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'device_id' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling deleteAccountDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual VoIP device. See Devices for more detail.
     * @summary Show details of an individual VoIP device.
     * @param accountId Account ID
     * @param deviceId Device ID
     */
    public getAccountDevice (accountId: number, deviceId: number) : Promise<{ response: http.ClientResponse; body: DeviceFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/devices/{device_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'device_id' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getAccountDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of VoIP devices associated with your account. See Devices for more detail.
     * @summary Get a list of VoIP devices associated with your account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountDevices (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListDevices;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/devices'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountDevices.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListDevices;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the details of an individual VoIP device. See Devices for more detail.
     * @summary Update the details of an individual VoIP device.
     * @param accountId Account ID
     * @param deviceId Device ID
     * @param data Device data
     */
    public replaceAccountDevice (accountId: number, deviceId: number, data?: CreateDeviceParams) : Promise<{ response: http.ClientResponse; body: DeviceFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/devices/{device_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'device_id' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountDevice.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling replaceAccountDevice.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExpressservicecodesApiApiKeys {
    apiKey,
}

export class ExpressservicecodesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExpressservicecodesApiApiKeys, value: string) {
        this.authentications[ExpressservicecodesApiApiKeys[key]].apiKey = value;
    }
    /**
     * This service shows the details of an Account Express Service Code.
     * @summary Show details of an account Express Service Code
     * @param accountId Account ID
     * @param codeId Device ID
     */
    public getAccountExpressSrvCode (accountId: number, codeId: number) : Promise<{ response: http.ClientResponse; body: ExpressServiceCodeFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/express-service-codes/{code_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'code_id' + '}', String(codeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountExpressSrvCode.');
        }

        // verify required parameter 'codeId' is not null or undefined
        if (codeId === null || codeId === undefined) {
            throw new Error('Required parameter codeId was null or undefined when calling getAccountExpressSrvCode.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExpressServiceCodeFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the Express Service Code associated with your account in list format. See Express Service Codes for more detail.
     * @summary Get the Express Service Code associated with your account in list format.
     * @param accountId Account ID
     * @param filters[id] ID filter
     */
    public listAccountExpressSrvCodes (accountId: number, filters[id]?: Array<string>) : Promise<{ response: http.ClientResponse; body: ListExpressServiceCodes;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/express-service-codes'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountExpressSrvCodes.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListExpressServiceCodes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExtensionsApiApiKeys {
    apiKey,
}

export class ExtensionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExtensionsApiApiKeys, value: string) {
        this.authentications[ExtensionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create an individual extension. See extension for more details.
     * @summary Create an individual extension.
     * @param accountId Account ID
     * @param data Account Extensions Data
     */
    public createAccountExtension (accountId: number, data?: CreateExtensionParams) : Promise<{ response: http.ClientResponse; body: ExtensionFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountExtension.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExtensionFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual extension. See extension for more details.
     * @summary Show details of an individual extension.
     * @param accountId Account ID
     * @param extensionId Extension ID
     */
    public getAccountExtension (accountId: number, extensionId: number) : Promise<{ response: http.ClientResponse; body: ExtensionFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountExtension.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling getAccountExtension.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExtensionFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of extensions visible to the authenticated user or client. See extension for more details.
     * @summary Get a list of extensions visible to the authenticated user or client.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[extension] Extension filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[extension] Extension sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountExtensions (accountId: number, filters[id]?: Array<string>, filters[extension]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[extension]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListExtensions;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountExtensions.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[extension] !== undefined) {
            queryParameters['filters[extension]'] = filters[extension];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[extension] !== undefined) {
            queryParameters['sort[extension]'] = sort[extension];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListExtensions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace an individual extension. See extension for more details.
     * @summary Replace an individual extension.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param data Account Extensions Data
     */
    public replaceAccountExtension (accountId: number, extensionId: number, data?: ReplaceExtensionParams) : Promise<{ response: http.ClientResponse; body: ExtensionFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountExtension.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling replaceAccountExtension.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExtensionFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GroupsApiApiKeys {
    apiKey,
}

export class GroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GroupsApiApiKeys, value: string) {
        this.authentications[GroupsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a new contact group to an account extension. See Account Contact Groups for details on the properties.
     * @summary Add a new contact group to an account extension.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param data Group data
     */
    public createAccountExtensionContactGroup (accountId: number, extensionId: number, data: CreateGroupParams) : Promise<{ response: http.ClientResponse; body: GroupFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contact-groups'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountExtensionContactGroup.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling createAccountExtensionContactGroup.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createAccountExtensionContactGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a contact group from the address book. See Account Contact Groups for details on the properties.
     * @summary Delete a contact group from the address book.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param groupId Group ID
     */
    public deleteAccountExtensionContactGroup (accountId: number, extensionId: number, groupId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contact-groups/{group_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId))
            .replace('{' + 'group_id' + '}', String(groupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountExtensionContactGroup.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling deleteAccountExtensionContactGroup.');
        }

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling deleteAccountExtensionContactGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the information of a contact group. See Account Contact Groups for details on the properties.
     * @summary Retrieve the information of a contact group.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param groupId Group ID
     */
    public getAccountExtensionContactGroup (accountId: number, extensionId: number, groupId: number) : Promise<{ response: http.ClientResponse; body: GroupFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contact-groups/{group_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId))
            .replace('{' + 'group_id' + '}', String(groupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountExtensionContactGroup.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling getAccountExtensionContactGroup.');
        }

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getAccountExtensionContactGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show a list of contact groups belonging to an extension. See Account Contact Groups for details on the properties.
     * @summary Show a list of contact groups belonging to an extension.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountExtensionContactGroups (accountId: number, extensionId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListGroups;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contact-groups'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountExtensionContactGroups.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling listAccountExtensionContactGroups.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListGroups;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the information of a contact group. See Account Contact Groups for details on the properties.
     * @summary Update the information of a contact group.
     * @param accountId Account ID
     * @param extensionId Extension ID
     * @param groupId Group ID
     * @param data Group data
     */
    public replaceAccountExtensionContactGroup (accountId: number, extensionId: number, groupId: number, data: CreateGroupParams) : Promise<{ response: http.ClientResponse; body: GroupFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/extensions/{extension_id}/contact-groups/{group_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'extension_id' + '}', String(extensionId))
            .replace('{' + 'group_id' + '}', String(groupId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountExtensionContactGroup.');
        }

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling replaceAccountExtensionContactGroup.');
        }

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling replaceAccountExtensionContactGroup.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling replaceAccountExtensionContactGroup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ListenersApiApiKeys {
    apiKey,
}

export class ListenersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ListenersApiApiKeys, value: string) {
        this.authentications[ListenersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a listener object to your account that can be used to subscribe an event. See Account Listeners for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level Post Listener API with the following definition: POST https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/listeners
     * @summary Add a listener object to your account that can be used to subscribe an event.
     * @param accountId Account ID
     * @param data Account Listeners Data
     */
    public createAccountListener (accountId: number, data?: CreateListenerParams) : Promise<{ response: http.ClientResponse; body: ListenerFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/listeners'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountListener.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListenerFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an individual event listener. See Account Listeners for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level Delete Listener API with the following definition: DELETE https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/listeners/:listener_id
     * @summary Delete an individual event listener.
     * @param accountId Account ID
     * @param listenerId Listener ID
     */
    public deleteAccountListener (accountId: number, listenerId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/listeners/{listener_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'listener_id' + '}', String(listenerId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountListener.');
        }

        // verify required parameter 'listenerId' is not null or undefined
        if (listenerId === null || listenerId === undefined) {
            throw new Error('Required parameter listenerId was null or undefined when calling deleteAccountListener.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual event listener. See Account Listeners for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level Get Listener API with the following definition: GET https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/listeners/:listener_id
     * @summary Show details of an individual listener.
     * @param accountId Account ID
     * @param listenerId Listener ID
     */
    public getAccountListener (accountId: number, listenerId: number) : Promise<{ response: http.ClientResponse; body: ListenerFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/listeners/{listener_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'listener_id' + '}', String(listenerId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountListener.');
        }

        // verify required parameter 'listenerId' is not null or undefined
        if (listenerId === null || listenerId === undefined) {
            throw new Error('Required parameter listenerId was null or undefined when calling getAccountListener.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListenerFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of listeners for an account. See Account Listeners for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level List Listeners API with the following definition: GET https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/listeners
     * @summary Get a list of listeners for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param sort[id] ID sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountListeners (accountId: number, filters[id]?: Array<string>, sort[id]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListListeners;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/listeners'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountListeners.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListListeners;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the settings of an individual event listener. See Event Listeners for more detail. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level Replace Listener API with the following definition: PUT https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/listeners/:listener_id
     * @summary Update the settings of an individual event listener.
     * @param accountId Account ID
     * @param listenerId Listener ID
     * @param data Account Listeners Data
     */
    public replaceAccountListener (accountId: number, listenerId: number, data?: CreateListenerParams) : Promise<{ response: http.ClientResponse; body: ListenerFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/listeners/{listener_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'listener_id' + '}', String(listenerId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountListener.');
        }

        // verify required parameter 'listenerId' is not null or undefined
        if (listenerId === null || listenerId === undefined) {
            throw new Error('Required parameter listenerId was null or undefined when calling replaceAccountListener.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListenerFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaApiApiKeys {
    apiKey,
}

export class MediaApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MediaApiApiKeys, value: string) {
        this.authentications[MediaApiApiKeys[key]].apiKey = value;
    }
    /**
     * See Account Media for more info on the properties.
     * @summary Add a media object to your account that can be used as a greeting or hold music. Users may create a media by using the built-in Text-to-speech (TTS) facility or upload a file of their choice. (Note: The maximum size for media files or JSON objects included with a POST or PUT request is 10 MB)
     * @param accountId Account ID
     * @param json Media extra parameters
     * @param file Media file
     */
    public createAccountMediaFiles (accountId: number, json?: string, file?: Buffer) : Promise<{ response: http.ClientResponse; body: MediaFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/media/files'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountMediaFiles.');
        }

        let useFormData = false;

        if (json !== undefined) {
            formParams['json'] = json;
        }

        if (file !== undefined) {
            formParams['file'] = file;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MediaFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See Account Media for more info on the properties.
     * @summary Add a media object to your account that can be used as a greeting or hold music. Users may create a media by using the built-in Text-to-speech (TTS) facility or upload a file of their choice. (Note: The maximum size for media files or JSON objects included with a POST or PUT request is 10 MB)
     * @param accountId Account ID
     * @param data Media data
     */
    public createAccountMediaTts (accountId: number, data?: CreateMediaParams) : Promise<{ response: http.ClientResponse; body: MediaFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/media/tts'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountMediaTts.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MediaFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See Account Media for more info on the properties.
     * @summary Delete an individual media record
     * @param accountId Account ID
     * @param mediaId Media ID
     */
    public deleteAccountMedia (accountId: number, mediaId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/media/{media_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'media_id' + '}', String(mediaId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountMedia.');
        }

        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling deleteAccountMedia.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get individual media recording
     * @summary Show details of an individual media recording (Greeting or Hold Music)
     * @param accountId Account ID
     * @param mediaId Media ID
     */
    public getAccountMedia (accountId: number, mediaId: number) : Promise<{ response: http.ClientResponse; body: MediaFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/media/{media_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'media_id' + '}', String(mediaId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMedia.');
        }

        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling getAccountMedia.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MediaFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of media recordings for an account. See Account Media for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level List Media API with the following definition: GET https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/media
     * @summary Get a list of media recordings for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountMedia (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListMedia;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/media'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountMedia.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListMedia;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * See Account Media for more info on the properties.
     * @summary Update a media object to your account. Note: The maximum size for media files or JSON objects included with a POST or PUT request is 10 MB.
     * @param accountId Account ID
     * @param mediaId Media ID
     * @param json Media extra parameters
     * @param file Media file
     */
    public replaceAccountMediaFiles (accountId: number, mediaId: number, json?: string, file?: Buffer) : Promise<{ response: http.ClientResponse; body: MediaFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/media/files/{media_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'media_id' + '}', String(mediaId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountMediaFiles.');
        }

        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling replaceAccountMediaFiles.');
        }

        let useFormData = false;

        if (json !== undefined) {
            formParams['json'] = json;
        }

        if (file !== undefined) {
            formParams['file'] = file;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MediaFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a media object to your account. Note: The maximum size for media files or JSON objects included with a POST or PUT request is 10 MB. See Account Media for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level Replace Media API with the following definition: PUT https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/media/:media_id
     * @summary Update a media object to your account.
     * @param accountId Account ID
     * @param mediaId Media ID
     * @param data Media data
     */
    public replaceAccountMediaTts (accountId: number, mediaId: number, data?: CreateMediaParams) : Promise<{ response: http.ClientResponse; body: MediaFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/media/tts/{media_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'media_id' + '}', String(mediaId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountMediaTts.');
        }

        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling replaceAccountMediaTts.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MediaFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MenusApiApiKeys {
    apiKey,
}

export class MenusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MenusApiApiKeys, value: string) {
        this.authentications[MenusApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create an individual menu. See Account Menus for more info on the properties.
     * @summary Create an individual menu.
     * @param accountId Account ID
     * @param data Menu data
     */
    public createAccountMenu (accountId: number, data?: CreateMenuParams) : Promise<{ response: http.ClientResponse; body: MenuFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/menus'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MenuFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an individual menu. See Account Menus for more info on the properties.
     * @summary Delete an individual menu.
     * @param accountId Account ID
     * @param menuId Menu ID
     */
    public deleteAccountMenu (accountId: number, menuId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/menus/{menu_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'menu_id' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountMenu.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling deleteAccountMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual menu. See Account Menus for more info on the properties.
     * @summary Show details of an individual menu.
     * @param accountId Account ID
     * @param menuId Menu ID
     */
    public getAccountMenu (accountId: number, menuId: number) : Promise<{ response: http.ClientResponse; body: MenuFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/menus/{menu_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'menu_id' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountMenu.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling getAccountMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MenuFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of menus for an account. See Account Menus for more info on the properties.
     * @summary Get a list of menus for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountMenus (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListMenus;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/menus'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountMenus.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListMenus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace an individual menu. See Account Menus for more info on the properties.
     * @summary Replace an individual menu.
     * @param accountId Account ID
     * @param menuId Menu ID
     * @param data Menu data
     */
    public replaceAccountMenu (accountId: number, menuId: number, data?: ReplaceMenuParams) : Promise<{ response: http.ClientResponse; body: MenuFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/menus/{menu_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'menu_id' + '}', String(menuId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountMenu.');
        }

        // verify required parameter 'menuId' is not null or undefined
        if (menuId === null || menuId === undefined) {
            throw new Error('Required parameter menuId was null or undefined when calling replaceAccountMenu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MenuFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NumberregionsApiApiKeys {
    apiKey,
}

export class NumberregionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NumberregionsApiApiKeys, value: string) {
        this.authentications[NumberregionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * This service lists the quantities of available phone numbers by region.
     * @summary 
     * @param filters[countryCode] Country Code filter
     * @param filters[npa] Area Code filter (North America only)
     * @param filters[nxx] 2nd set of 3 digits filter (North America only)
     * @param filters[isTollFree] Toll-free status filter
     * @param filters[city] City filter
     * @param filters[provincePostalCode] State or Province filter
     * @param filters[countryPostalCode] Country filter
     * @param sort[countryCode] International calling code sorting
     * @param sort[npa] Area Code sorting (North America only)
     * @param sort[nxx] 2nd set of 3 digits sorting (North America)
     * @param sort[isTollFree] Toll Free status sorting
     * @param sort[city] City sorting
     * @param sort[provincePostalCode] State or Province sorting
     * @param sort[countryPostalCode] Country sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     * @param groupBy Fields to group by (supports the same set of fields as the filters and sorting)
     */
    public listAvailablePhoneNumberRegions (filters[countryCode]?: Array<string>, filters[npa]?: Array<string>, filters[nxx]?: Array<string>, filters[isTollFree]?: Array<string>, filters[city]?: Array<string>, filters[provincePostalCode]?: Array<string>, filters[countryPostalCode]?: Array<string>, sort[countryCode]?: string, sort[npa]?: string, sort[nxx]?: string, sort[isTollFree]?: string, sort[city]?: string, sort[provincePostalCode]?: string, sort[countryPostalCode]?: string, limit?: number, offset?: number, fields?: string, groupBy?: Array<string>) : Promise<{ response: http.ClientResponse; body: ListPhoneNumbersRegions;  }> {
        const localVarPath = this.basePath + '/phone-numbers/available/regions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (filters[countryCode] !== undefined) {
            queryParameters['filters[country_code]'] = filters[countryCode];
        }

        if (filters[npa] !== undefined) {
            queryParameters['filters[npa]'] = filters[npa];
        }

        if (filters[nxx] !== undefined) {
            queryParameters['filters[nxx]'] = filters[nxx];
        }

        if (filters[isTollFree] !== undefined) {
            queryParameters['filters[is_toll_free]'] = filters[isTollFree];
        }

        if (filters[city] !== undefined) {
            queryParameters['filters[city]'] = filters[city];
        }

        if (filters[provincePostalCode] !== undefined) {
            queryParameters['filters[province_postal_code]'] = filters[provincePostalCode];
        }

        if (filters[countryPostalCode] !== undefined) {
            queryParameters['filters[country_postal_code]'] = filters[countryPostalCode];
        }

        if (sort[countryCode] !== undefined) {
            queryParameters['sort[country_code]'] = sort[countryCode];
        }

        if (sort[npa] !== undefined) {
            queryParameters['sort[npa]'] = sort[npa];
        }

        if (sort[nxx] !== undefined) {
            queryParameters['sort[nxx]'] = sort[nxx];
        }

        if (sort[isTollFree] !== undefined) {
            queryParameters['sort[is_toll_free]'] = sort[isTollFree];
        }

        if (sort[city] !== undefined) {
            queryParameters['sort[city]'] = sort[city];
        }

        if (sort[provincePostalCode] !== undefined) {
            queryParameters['sort[province_postal_code]'] = sort[provincePostalCode];
        }

        if (sort[countryPostalCode] !== undefined) {
            queryParameters['sort[country_postal_code]'] = sort[countryPostalCode];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        if (groupBy !== undefined) {
            queryParameters['group_by'] = groupBy;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListPhoneNumbersRegions;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OauthApiApiKeys {
    apiKey,
}

export class OauthApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OauthApiApiKeys, value: string) {
        this.authentications[OauthApiApiKeys[key]].apiKey = value;
    }
    /**
     * To create an access token via the /oauth/access-token API, an API user may choose any one of the grant types it supports: Authorization Code Grant, Client Credential Grant, Password Credential Grant or Refresh Token Grant. For Authorization Code Grant, the input parameter 'code' is generated via the Create Authorization API. NOTE: The Create Access Token API now accepts requests in query string format as well as JSON body format. See OAuth for more details on how to obtain client id and client secret to create an access token at real time.
     * @summary To create an access token via the /oauth/access-token API, an API user may choose any one of the grant types it supports: Authorization Code Grant, Client Credential Grant, Password Credential Grant or Refresh Token Grant.
     * @param data Oauth data
     */
    public createOauthAccessToken (data?: CreateOauthParams) : Promise<{ response: http.ClientResponse; body: OauthAccessToken;  }> {
        const localVarPath = this.basePath + '/oauth/access-token';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthAccessToken;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create Authorization Code or Access Token. The /oauth/authorization API supports Authorization Grant and Implicit Grant. In Authorization Grant, this API returns a code (response_type=code) for clients implemented in a browser using a scripting language such as JavaScript. Users may then use the code via the Create Access Token API to create an access token. The Implicit Grant is a simplified authorization code flow. In the implicit flow, instead of issuing the client an authorization code, the client is issued an access token (response_type=token) directly. See OAuth for more details on how to obtain client id and client secret to create authorization code access token at real time.
     * @summary Create Authorization Code or Access Token.
     * @param clientId Client ID
     * @param responseType &#39;token&#39; for Implicit Grant; &#39;code&#39; for Authorization Code Grant
     * @param scope account-owner, extension-user and/or methods:ALL, separated by space (%20)
     * @param redirectUri The URL where the response data of this API is redirected to
     */
    public createOauthAuthorization (clientId: string, responseType: string, scope: string, redirectUri: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/oauth/authorization';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling createOauthAuthorization.');
        }

        // verify required parameter 'responseType' is not null or undefined
        if (responseType === null || responseType === undefined) {
            throw new Error('Required parameter responseType was null or undefined when calling createOauthAuthorization.');
        }

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling createOauthAuthorization.');
        }

        // verify required parameter 'redirectUri' is not null or undefined
        if (redirectUri === null || redirectUri === undefined) {
            throw new Error('Required parameter redirectUri was null or undefined when calling createOauthAuthorization.');
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (responseType !== undefined) {
            queryParameters['response_type'] = responseType;
        }

        if (scope !== undefined) {
            queryParameters['scope'] = scope;
        }

        if (redirectUri !== undefined) {
            queryParameters['redirect_uri'] = redirectUri;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve details of an access token, such as scope, expiration and extension ID. Voip ID will be returned as well if scope contains account-owner scope.
     * @summary Retrieve details of an access token, such as scope, expiration and extension ID.
     */
    public getOauthAccessToken () : Promise<{ response: http.ClientResponse; body: GetOauthAccessToken;  }> {
        const localVarPath = this.basePath + '/oauth/access-token';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetOauthAccessToken;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OauthclientsApiApiKeys {
    apiKey,
}

export class OauthclientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OauthclientsApiApiKeys, value: string) {
        this.authentications[OauthclientsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Delete an individual OAuth client. See Account OAuth Clients for more info on the properties.
     * @summary Delete an individual OAuth client.
     * @param accountId Account ID
     * @param clientId Client ID
     */
    public deleteAccountOauthClient (accountId: number, clientId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/oauth/clients/{client_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'client_id' + '}', String(clientId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountOauthClient.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling deleteAccountOauthClient.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual OAuth client. See Account OAuth Clients for more info on the properties.
     * @summary Show details of an individual OAuth client.
     * @param accountId Account ID
     * @param clientId Client ID
     */
    public getAccountOauthClient (accountId: number, clientId: number) : Promise<{ response: http.ClientResponse; body: OauthClientFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/oauth/clients/{client_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'client_id' + '}', String(clientId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountOauthClient.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getAccountOauthClient.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthClientFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of OAuth clients for an account. See Account OAuth Clients for more info on the properties.
     * @summary Get a list of OAuth clients for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param sort[id] ID sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountOauthClients (accountId: number, filters[id]?: Array<string>, sort[id]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListOauthClients;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/oauth/clients'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountOauthClients.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListOauthClients;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OauthclientsredirecturisApiApiKeys {
    apiKey,
}

export class OauthclientsredirecturisApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OauthclientsredirecturisApiApiKeys, value: string) {
        this.authentications[OauthclientsredirecturisApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create an OAuth Client Redirect URI record.
     * @summary Create an OAuth Client Redirect URI record.
     * @param accountId Account ID
     * @param clientId Client ID
     * @param data Redirect Uri data
     */
    public createAccountOauthClientsRedirectUri (accountId: number, clientId: number, data?: CreateRedirectUriParams) : Promise<{ response: http.ClientResponse; body: OauthClientRedirectUriFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/oauth/clients/{client_id}/redirect-uris'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'client_id' + '}', String(clientId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountOauthClientsRedirectUri.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling createAccountOauthClientsRedirectUri.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthClientRedirectUriFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an OAuth Client Redirect URI record.
     * @summary Delete an OAuth Client Redirect URI record.
     * @param accountId Account ID
     * @param clientId Client ID
     * @param uriId Redirect URI ID
     */
    public deleteAccountOauthClientsRedirectUri (accountId: number, clientId: number, uriId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/oauth/clients/{client_id}/redirect-uris/{uri_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'client_id' + '}', String(clientId))
            .replace('{' + 'uri_id' + '}', String(uriId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountOauthClientsRedirectUri.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling deleteAccountOauthClientsRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling deleteAccountOauthClientsRedirectUri.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get details of an OAuth Client Redirect URI record.
     * @summary Get details of an OAuth Client Redirect URI record.
     * @param accountId Account ID
     * @param clientId Client ID
     * @param uriId Redirect URI ID
     */
    public getAccountOauthClientsRedirectUri (accountId: number, clientId: number, uriId: number) : Promise<{ response: http.ClientResponse; body: OauthClientRedirectUriFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/oauth/clients/{client_id}/redirect-uris/{uri_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'client_id' + '}', String(clientId))
            .replace('{' + 'uri_id' + '}', String(uriId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountOauthClientsRedirectUri.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getAccountOauthClientsRedirectUri.');
        }

        // verify required parameter 'uriId' is not null or undefined
        if (uriId === null || uriId === undefined) {
            throw new Error('Required parameter uriId was null or undefined when calling getAccountOauthClientsRedirectUri.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthClientRedirectUriFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of OAuth Client Redirect URIs for an account.
     * @summary Get a list of OAuth Client Redirect URIs for an account.
     * @param accountId Account ID
     * @param clientId Client ID
     * @param filters[id] ID filter
     * @param sort[id] ID sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountOauthClientsRedirectUris (accountId: number, clientId: number, filters[id]?: Array<string>, sort[id]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListOauthClientsRedirectUris;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/oauth/clients/{client_id}/redirect-uris'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'client_id' + '}', String(clientId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountOauthClientsRedirectUris.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling listAccountOauthClientsRedirectUris.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListOauthClientsRedirectUris;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentmethodsApiApiKeys {
    apiKey,
}

export class PaymentmethodsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentmethodsApiApiKeys, value: string) {
        this.authentications[PaymentmethodsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create an individual payment method. See Account Payment Methods for more info on the properties.
     * @summary Create an individual payment method.
     * @param accountId Account ID
     * @param data Payment data
     */
    public createAccountPaymentMethod (accountId: number, data: CreatePaymentParams) : Promise<{ response: http.ClientResponse; body: PaymentFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/payment-methods'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountPaymentMethod.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createAccountPaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an individual payment method. See Account Payment Methods for more info on the properties.
     * @summary Delete an individual payment method.
     * @param accountId Account ID
     * @param pmId Payment Method ID
     */
    public deleteAccountPaymentMethod (accountId: number, pmId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/payment-methods/{pm_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'pm_id' + '}', String(pmId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountPaymentMethod.');
        }

        // verify required parameter 'pmId' is not null or undefined
        if (pmId === null || pmId === undefined) {
            throw new Error('Required parameter pmId was null or undefined when calling deleteAccountPaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual payment method. See Account Payment Methods for more info on the properties.
     * @summary Show details of an individual payment method.
     * @param accountId Account ID
     * @param pmId Payment Method ID
     */
    public getAccountPaymentMethod (accountId: number, pmId: number) : Promise<{ response: http.ClientResponse; body: PaymentFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/payment-methods/{pm_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'pm_id' + '}', String(pmId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountPaymentMethod.');
        }

        // verify required parameter 'pmId' is not null or undefined
        if (pmId === null || pmId === undefined) {
            throw new Error('Required parameter pmId was null or undefined when calling getAccountPaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of payment methods for an account. See Account Payment Methods for more info on the properties.
     * @summary Get a list of payment methods for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param sort[id] ID sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountPaymentMethods (accountId: number, filters[id]?: Array<string>, sort[id]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListPaymentMethods;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/payment-methods'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountPaymentMethods.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListPaymentMethods;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace the status of an individual payment method. See Account Payment Methods for more info on the properties.
     * @summary Replace the status of an individual payment method.
     * @param accountId Account ID
     * @param pmId Payment Method ID
     * @param data Payment data
     */
    public patchAccountPaymentMethod (accountId: number, pmId: number, data?: PatchPaymentParams) : Promise<{ response: http.ClientResponse; body: PaymentFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/payment-methods/{pm_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'pm_id' + '}', String(pmId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling patchAccountPaymentMethod.');
        }

        // verify required parameter 'pmId' is not null or undefined
        if (pmId === null || pmId === undefined) {
            throw new Error('Required parameter pmId was null or undefined when calling patchAccountPaymentMethod.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PhonenumbersApiApiKeys {
    apiKey,
}

export class PhonenumbersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PhonenumbersApiApiKeys, value: string) {
        this.authentications[PhonenumbersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a phone number to an account. See Account Phone Numbers for more info on the properties.
     * @summary Add a phone number to an account.
     * @param accountId Account ID
     * @param data Phone Number data
     */
    public createAccountPhoneNumber (accountId: number, data?: CreatePhoneNumberParams) : Promise<{ response: http.ClientResponse; body: PhoneNumberFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/phone-numbers'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountPhoneNumber.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PhoneNumberFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual phone number. See Account Phone Numbers for more info on the properties.
     * @summary Show details of an individual phone number.
     * @param accountId Account ID
     * @param numberId Number ID
     */
    public getAccountPhoneNumber (accountId: number, numberId: number) : Promise<{ response: http.ClientResponse; body: PhoneNumberFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/phone-numbers/{number_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'number_id' + '}', String(numberId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountPhoneNumber.');
        }

        // verify required parameter 'numberId' is not null or undefined
        if (numberId === null || numberId === undefined) {
            throw new Error('Required parameter numberId was null or undefined when calling getAccountPhoneNumber.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PhoneNumberFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of phone numbers registered to an account. See Account Phone Numbers for more info on the properties.
     * @summary Get a list of phone numbers registered to an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param filters[phoneNumber] Phone number filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param sort[phoneNumber] Phone number sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountPhoneNumbers (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, filters[phoneNumber]?: Array<string>, sort[id]?: string, sort[name]?: string, sort[phoneNumber]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListPhoneNumbers;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/phone-numbers'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountPhoneNumbers.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (filters[phoneNumber] !== undefined) {
            queryParameters['filters[phone_number]'] = filters[phoneNumber];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (sort[phoneNumber] !== undefined) {
            queryParameters['sort[phone_number]'] = sort[phoneNumber];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListPhoneNumbers;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the settings for an existing phone number on your account. See Account Phone Numbers for more info on the properties.
     * @summary Update the settings for an existing phone number on your account.
     * @param accountId Account ID
     * @param numberId Number ID
     * @param data Phone Number data
     */
    public replaceAccountPhoneNumber (accountId: number, numberId: number, data?: ReplacePhoneNumberParams) : Promise<{ response: http.ClientResponse; body: PhoneNumberFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/phone-numbers/{number_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'number_id' + '}', String(numberId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountPhoneNumber.');
        }

        // verify required parameter 'numberId' is not null or undefined
        if (numberId === null || numberId === undefined) {
            throw new Error('Required parameter numberId was null or undefined when calling replaceAccountPhoneNumber.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PhoneNumberFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum QueuesApiApiKeys {
    apiKey,
}

export class QueuesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: QueuesApiApiKeys, value: string) {
        this.authentications[QueuesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a queue. See Account Queues for more info on the properties.
     * @summary Create a queue.
     * @param accountId Account ID
     * @param data Queue data
     */
    public createAccountQueue (accountId: number, data?: CreateQueueParams) : Promise<{ response: http.ClientResponse; body: QueueFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/queues'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountQueue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QueueFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a queue. See Account Queues for more info on the properties.
     * @summary Delete a queue.
     * @param accountId Account ID
     * @param queueId Queue ID
     */
    public deleteAccountQueue (accountId: number, queueId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/queues/{queue_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'queue_id' + '}', String(queueId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountQueue.');
        }

        // verify required parameter 'queueId' is not null or undefined
        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling deleteAccountQueue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual queue. See Account Queues for more info on the properties.
     * @summary Show details of an individual queue.
     * @param accountId Account ID
     * @param queueId Queue ID
     */
    public getAccountQueue (accountId: number, queueId: number) : Promise<{ response: http.ClientResponse; body: QueueFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/queues/{queue_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'queue_id' + '}', String(queueId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountQueue.');
        }

        // verify required parameter 'queueId' is not null or undefined
        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling getAccountQueue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QueueFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of queues for an account. See Account Queues for more info on the properties.
     * @summary Get a list of queues for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountQueues (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListQueues;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/queues'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountQueues.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListQueues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace a queue. See Account Queues for more info on the properties.
     * @summary Replace a queue.
     * @param accountId Account ID
     * @param queueId Queue ID
     * @param data Queue data
     */
    public replaceAccountQueue (accountId: number, queueId: number, data?: CreateQueueParams) : Promise<{ response: http.ClientResponse; body: QueueFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/queues/{queue_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'queue_id' + '}', String(queueId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountQueue.');
        }

        // verify required parameter 'queueId' is not null or undefined
        if (queueId === null || queueId === undefined) {
            throw new Error('Required parameter queueId was null or undefined when calling replaceAccountQueue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QueueFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RoutesApiApiKeys {
    apiKey,
}

export class RoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RoutesApiApiKeys, value: string) {
        this.authentications[RoutesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a new route to the account. See Intro to Routes for more info on the properties.
     * @summary Add a new route to the account.
     * @param accountId Account ID
     * @param data Route data
     */
    public createRoute (accountId: number, data?: CreateRouteParams) : Promise<{ response: http.ClientResponse; body: RouteFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/routes'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createRoute.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouteFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a route from the account. See Intro to Routes for more info on the properties.
     * @summary Delete a route from the account.
     * @param accountId Account ID
     * @param routeId Route ID
     */
    public deleteAccountRoute (accountId: number, routeId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/routes/{route_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'route_id' + '}', String(routeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountRoute.');
        }

        // verify required parameter 'routeId' is not null or undefined
        if (routeId === null || routeId === undefined) {
            throw new Error('Required parameter routeId was null or undefined when calling deleteAccountRoute.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual route. See Intro to Routes for more info on the properties.
     * @summary Show details of an individual route.
     * @param accountId Account ID
     * @param routeId Route ID
     */
    public getAccountRoute (accountId: number, routeId: number) : Promise<{ response: http.ClientResponse; body: RouteFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/routes/{route_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'route_id' + '}', String(routeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountRoute.');
        }

        // verify required parameter 'routeId' is not null or undefined
        if (routeId === null || routeId === undefined) {
            throw new Error('Required parameter routeId was null or undefined when calling getAccountRoute.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouteFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of routes for an account. See Intro to Routes for more info on the properties.
     * @summary Get a list of routes for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountRoutes (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListRoutes;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/routes'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountRoutes.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListRoutes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the information of a route. See Intro to Routes for more info on the properties.
     * @summary Update the information of a route.
     * @param accountId Account ID
     * @param routeId Route ID
     * @param data Route data
     */
    public replaceAccountRoute (accountId: number, routeId: number, data?: CreateRouteParams) : Promise<{ response: http.ClientResponse; body: RouteFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/routes/{route_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'route_id' + '}', String(routeId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountRoute.');
        }

        // verify required parameter 'routeId' is not null or undefined
        if (routeId === null || routeId === undefined) {
            throw new Error('Required parameter routeId was null or undefined when calling replaceAccountRoute.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouteFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SchedulesApiApiKeys {
    apiKey,
}

export class SchedulesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SchedulesApiApiKeys, value: string) {
        this.authentications[SchedulesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Show details of an individual schedule
     * @summary Show details of an individual schedule
     * @param accountId Account ID
     * @param scheduleId Schedule ID
     */
    public getAccountSchedule (accountId: number, scheduleId: number) : Promise<{ response: http.ClientResponse; body: ScheduleFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/schedules/{schedule_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'schedule_id' + '}', String(scheduleId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountSchedule.');
        }

        // verify required parameter 'scheduleId' is not null or undefined
        if (scheduleId === null || scheduleId === undefined) {
            throw new Error('Required parameter scheduleId was null or undefined when calling getAccountSchedule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ScheduleFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of schedules for an account
     * @summary Get a list of schedules for an account
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountSchedules (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListSchedules;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/schedules'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountSchedules.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListSchedules;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SmsApiApiKeys {
    apiKey,
}

export class SmsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SmsApiApiKeys, value: string) {
        this.authentications[SmsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Send a SMS to one or a group of recipients. For details on the input fields, see Intro to SMS. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level Create SMS API with the following definition: POST https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/sms
     * @summary Send a SMS to one or a group of recipients.
     * @param accountId Account ID
     * @param data SMS data
     */
    public createAccountSms (accountId: number, data: CreateSmsParams) : Promise<{ response: http.ClientResponse; body: SmsFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/sms'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountSms.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createAccountSms.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SmsFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This service shows the details of an individual SMS. See Intro to SMS for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level Get SMS API with the following definition: GET https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/sms/:sms_id
     * @summary This service shows the details of an individual SMS.
     * @param accountId Account ID
     * @param smsId SMS ID
     */
    public getAccountSms (accountId: number, smsId: string) : Promise<{ response: http.ClientResponse; body: SmsFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/sms/{sms_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'sms_id' + '}', String(smsId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountSms.');
        }

        // verify required parameter 'smsId' is not null or undefined
        if (smsId === null || smsId === undefined) {
            throw new Error('Required parameter smsId was null or undefined when calling getAccountSms.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SmsFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of SMS messages for an account. See Intro to SMS for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level List SMS API with the following definition: GET https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/sms
     * @summary Get a list of SMS messages for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[from] Caller ID filter
     * @param filters[to] Callee ID filter, the E.164 phone number to send the SMS TO. Note you must encode the + as %2B
     * @param filters[direction] Direction filter
     * @param filters[extension] Extension filter
     * @param filters[createdAt] Date string representing the UTC time that sms was created
     * @param sort[id] ID sorting
     * @param sort[createdAt] Sort by created time of message
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountSms (accountId: number, filters[id]?: Array<string>, filters[from]?: string, filters[to]?: string, filters[direction]?: string, filters[extension]?: Array<string>, filters[createdAt]?: string, sort[id]?: string, sort[createdAt]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListSms;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/sms'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountSms.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[from] !== undefined) {
            queryParameters['filters[from]'] = filters[from];
        }

        if (filters[to] !== undefined) {
            queryParameters['filters[to]'] = filters[to];
        }

        if (filters[direction] !== undefined) {
            queryParameters['filters[direction]'] = filters[direction];
        }

        if (filters[extension] !== undefined) {
            queryParameters['filters[extension]'] = filters[extension];
        }

        if (filters[createdAt] !== undefined) {
            queryParameters['filters[created_at]'] = filters[createdAt];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[createdAt] !== undefined) {
            queryParameters['sort[created_at]'] = sort[createdAt];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListSms;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the is_new parameter in a sms record. See Account SMS for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Extension level Patch SMS API with the following definition: PATCH https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/sms/:sms_id
     * @summary Update the is_new parameter in a sms record.
     * @param accountId Account ID
     * @param smsId SMS ID
     * @param data Sms data
     */
    public patchAccountSms (accountId: number, smsId: string, data?: PatchSmsParams) : Promise<{ response: http.ClientResponse; body: SmsFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/sms/{sms_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'sms_id' + '}', String(smsId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling patchAccountSms.');
        }

        // verify required parameter 'smsId' is not null or undefined
        if (smsId === null || smsId === undefined) {
            throw new Error('Required parameter smsId was null or undefined when calling patchAccountSms.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SmsFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubaccountpricingApiApiKeys {
    apiKey,
}

export class SubaccountpricingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubaccountpricingApiApiKeys, value: string) {
        this.authentications[SubaccountpricingApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a pricing plan to a subaccount. See Account Subaccount Pricing for more info on the properties.
     * @summary Add a pricing plan to a subaccount.
     * @param accountId Account ID
     * @param subaccountId Subaccount ID
     * @param data Subaccount pricing data
     */
    public createAccountSubaccountPricing (accountId: number, subaccountId: number, data: CreatePricingParams) : Promise<{ response: http.ClientResponse; body: PricingFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/subaccounts/{subaccount_id}/pricing'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'subaccount_id' + '}', String(subaccountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountSubaccountPricing.');
        }

        // verify required parameter 'subaccountId' is not null or undefined
        if (subaccountId === null || subaccountId === undefined) {
            throw new Error('Required parameter subaccountId was null or undefined when calling createAccountSubaccountPricing.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createAccountSubaccountPricing.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PricingFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a pricing plan from a subaccount. See Account Subaccount Pricing for more info on the properties.
     * @summary Delete a pricing plan from a subaccount.
     * @param accountId Account ID
     * @param subaccountId Subaccount ID
     * @param pricingId Pricing Object ID
     */
    public deleteAccountSubaccountPricing (accountId: number, subaccountId: number, pricingId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/subaccounts/{subaccount_id}/pricing/{pricing_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'subaccount_id' + '}', String(subaccountId))
            .replace('{' + 'pricing_id' + '}', String(pricingId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountSubaccountPricing.');
        }

        // verify required parameter 'subaccountId' is not null or undefined
        if (subaccountId === null || subaccountId === undefined) {
            throw new Error('Required parameter subaccountId was null or undefined when calling deleteAccountSubaccountPricing.');
        }

        // verify required parameter 'pricingId' is not null or undefined
        if (pricingId === null || pricingId === undefined) {
            throw new Error('Required parameter pricingId was null or undefined when calling deleteAccountSubaccountPricing.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the details of a pricing plan for a subaccount. See Account Subaccount Pricing for more info on the properties.
     * @summary Get the details of a pricing plan for a subaccount.
     * @param accountId Account ID
     * @param subaccountId Subaccount ID
     * @param pricingId Pricing Object ID
     */
    public getAccountSubaccountPricing (accountId: number, subaccountId: number, pricingId: number) : Promise<{ response: http.ClientResponse; body: PricingFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/subaccounts/{subaccount_id}/pricing/{pricing_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'subaccount_id' + '}', String(subaccountId))
            .replace('{' + 'pricing_id' + '}', String(pricingId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountSubaccountPricing.');
        }

        // verify required parameter 'subaccountId' is not null or undefined
        if (subaccountId === null || subaccountId === undefined) {
            throw new Error('Required parameter subaccountId was null or undefined when calling getAccountSubaccountPricing.');
        }

        // verify required parameter 'pricingId' is not null or undefined
        if (pricingId === null || pricingId === undefined) {
            throw new Error('Required parameter pricingId was null or undefined when calling getAccountSubaccountPricing.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PricingFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of pricing plans for a subaccount. See Account Subaccount Pricing for more info on the properties.
     * @summary Get a list of pricing plans for a subaccount.
     * @param accountId Account ID
     * @param subaccountId Subaccount ID
     * @param filters[id] ID filter
     * @param sort[id] ID sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountSubaccountPricing (accountId: number, subaccountId: number, filters[id]?: Array<string>, sort[id]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListPricings;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/subaccounts/{subaccount_id}/pricing'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'subaccount_id' + '}', String(subaccountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountSubaccountPricing.');
        }

        // verify required parameter 'subaccountId' is not null or undefined
        if (subaccountId === null || subaccountId === undefined) {
            throw new Error('Required parameter subaccountId was null or undefined when calling listAccountSubaccountPricing.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListPricings;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubaccountsApiApiKeys {
    apiKey,
}

export class SubaccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubaccountsApiApiKeys, value: string) {
        this.authentications[SubaccountsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a subaccount for the authenticated user or client
     * @summary Add a subaccount for the authenticated user or client
     * @param accountId Account ID
     * @param data Subaccount data
     */
    public createAccountSubaccount (accountId: number, data: CreateSubaccountParams) : Promise<{ response: http.ClientResponse; body: AccountFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/subaccounts'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountSubaccount.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createAccountSubaccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccountFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of subaccounts for the authenticated user or client
     * @summary Get a list of subaccounts for the authenticated user or client
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param sort[id] ID sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountSubaccounts (accountId: number, filters[id]?: Array<string>, sort[id]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListAccounts;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/subaccounts'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountSubaccounts.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListAccounts;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TrunksApiApiKeys {
    apiKey,
}

export class TrunksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TrunksApiApiKeys, value: string) {
        this.authentications[TrunksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a trunk record with SIP information. See Account Trunks for more info on the properties.
     * @summary Add a trunk record with SIP information.
     * @param accountId Account ID
     * @param data Trunk data
     */
    public createAccountTrunk (accountId: number, data: CreateTrunkParams) : Promise<{ response: http.ClientResponse; body: TrunkFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/trunks'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountTrunk.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createAccountTrunk.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TrunkFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a trunk from account. See Account Trunks for more info on the properties.
     * @summary Delete a trunk from account.
     * @param accountId Account ID
     * @param trunkId Trunk ID
     */
    public deleteAccountTrunk (accountId: number, trunkId: number) : Promise<{ response: http.ClientResponse; body: DeleteEntry;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/trunks/{trunk_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'trunk_id' + '}', String(trunkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountTrunk.');
        }

        // verify required parameter 'trunkId' is not null or undefined
        if (trunkId === null || trunkId === undefined) {
            throw new Error('Required parameter trunkId was null or undefined when calling deleteAccountTrunk.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeleteEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Show details of an individual trunk. See Account Trunks for more info on the properties.
     * @summary Show details of an individual trunk.
     * @param accountId Account ID
     * @param trunkId Trunk ID
     */
    public getAccountTrunk (accountId: number, trunkId: number) : Promise<{ response: http.ClientResponse; body: TrunkFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/trunks/{trunk_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'trunk_id' + '}', String(trunkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountTrunk.');
        }

        // verify required parameter 'trunkId' is not null or undefined
        if (trunkId === null || trunkId === undefined) {
            throw new Error('Required parameter trunkId was null or undefined when calling getAccountTrunk.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TrunkFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of trunks for an account. See Account Trunks for more info on the properties.
     * @summary Get a list of trunks for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[name] Name filter
     * @param sort[id] ID sorting
     * @param sort[name] Name sorting
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountTrunks (accountId: number, filters[id]?: Array<string>, filters[name]?: Array<string>, sort[id]?: string, sort[name]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListTrunks;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/trunks'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountTrunks.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[name] !== undefined) {
            queryParameters['filters[name]'] = filters[name];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[name] !== undefined) {
            queryParameters['sort[name]'] = sort[name];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListTrunks;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace parameters in a trunk. See Account Trunks for more info on the properties.
     * @summary Replace parameters in a trunk.
     * @param accountId Account ID
     * @param trunkId Trunk ID
     * @param data Trunk data
     */
    public replaceAccountTrunk (accountId: number, trunkId: number, data: CreateTrunkParams) : Promise<{ response: http.ClientResponse; body: TrunkFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/trunks/{trunk_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'trunk_id' + '}', String(trunkId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling replaceAccountTrunk.');
        }

        // verify required parameter 'trunkId' is not null or undefined
        if (trunkId === null || trunkId === undefined) {
            throw new Error('Required parameter trunkId was null or undefined when calling replaceAccountTrunk.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling replaceAccountTrunk.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TrunkFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VoicemailApiApiKeys {
    apiKey,
}

export class VoicemailApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VoicemailApiApiKeys, value: string) {
        this.authentications[VoicemailApiApiKeys[key]].apiKey = value;
    }
    /**
     * This service shows the details of an individual voicemail. See Intro to Voicemail for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Get Voicemail API with the following definition: GET https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/voicemail/:voicemail_id
     * @summary This service shows the details of an individual voicemail.
     * @param accountId Account ID
     * @param voicemailId Voicemail ID
     */
    public getAccountVoicemail (accountId: number, voicemailId: string) : Promise<{ response: http.ClientResponse; body: VoicemailFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/voicemail/{voicemail_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'voicemail_id' + '}', String(voicemailId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAccountVoicemail.');
        }

        // verify required parameter 'voicemailId' is not null or undefined
        if (voicemailId === null || voicemailId === undefined) {
            throw new Error('Required parameter voicemailId was null or undefined when calling getAccountVoicemail.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VoicemailFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of voicemail messages for an account. See Intro to Voicemail for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the List Voicemail API with the following definition: GET https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/voicemail
     * @summary Get a list of voicemail messages for an account.
     * @param accountId Account ID
     * @param filters[id] ID filter
     * @param filters[from] Caller ID filter
     * @param filters[to] Callee ID filter, the E.164 phone number to send the SMS TO. Note you must encode the + as %2B
     * @param filters[isNew] 
     * @param filters[createdAt] Date string representing the UTC time that sms was created
     * @param filters[extension] Extension filter
     * @param sort[id] ID sorting
     * @param sort[createdAt] Sort by the UTC time that voicemail was created
     * @param limit Max results
     * @param offset Results to skip
     * @param fields Field set
     */
    public listAccountVoicemail (accountId: number, filters[id]?: Array<string>, filters[from]?: string, filters[to]?: string, filters[isNew]?: boolean, filters[createdAt]?: string, filters[extension]?: Array<string>, sort[id]?: string, sort[createdAt]?: string, limit?: number, offset?: number, fields?: string) : Promise<{ response: http.ClientResponse; body: ListVoicemail;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/voicemail'
            .replace('{' + 'account_id' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listAccountVoicemail.');
        }

        if (filters[id] !== undefined) {
            queryParameters['filters[id]'] = filters[id];
        }

        if (filters[from] !== undefined) {
            queryParameters['filters[from]'] = filters[from];
        }

        if (filters[to] !== undefined) {
            queryParameters['filters[to]'] = filters[to];
        }

        if (filters[isNew] !== undefined) {
            queryParameters['filters[is_new]'] = filters[isNew];
        }

        if (filters[createdAt] !== undefined) {
            queryParameters['filters[created_at]'] = filters[createdAt];
        }

        if (filters[extension] !== undefined) {
            queryParameters['filters[extension]'] = filters[extension];
        }

        if (sort[id] !== undefined) {
            queryParameters['sort[id]'] = sort[id];
        }

        if (sort[createdAt] !== undefined) {
            queryParameters['sort[created_at]'] = sort[createdAt];
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (fields !== undefined) {
            queryParameters['fields'] = fields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListVoicemail;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the is_new parameter in a voicemail record. See Account Voicemail for more info on the properties. Note: This API is for users with Account Owner scope access token. Users with Extension User scope token should invoke the Patch Voicemail API with the following definition: PATCH https://api.phone.com/v4/accounts/:account_id/extensions/:extension_id/voicemail/:voicemail_id
     * @summary Update the is_new parameter in a voicemail record.
     * @param accountId Account ID
     * @param voicemailId Voicemail ID
     * @param data Payment data
     */
    public patchAccountVoicemail (accountId: number, voicemailId: string, data?: PatchVoicemailParams) : Promise<{ response: http.ClientResponse; body: VoicemailFull;  }> {
        const localVarPath = this.basePath + '/accounts/{account_id}/voicemail/{voicemail_id}'
            .replace('{' + 'account_id' + '}', String(accountId))
            .replace('{' + 'voicemail_id' + '}', String(voicemailId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling patchAccountVoicemail.');
        }

        // verify required parameter 'voicemailId' is not null or undefined
        if (voicemailId === null || voicemailId === undefined) {
            throw new Error('Required parameter voicemailId was null or undefined when calling patchAccountVoicemail.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.apiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VoicemailFull;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
